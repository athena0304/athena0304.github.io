<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="Athena">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Athena">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Athena">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Athena </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?15fcb8c2aa27ecb358060d2600aa2502";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Athena</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">雨过天晴处</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/11/Element-ui升级2.0后初体验/" itemprop="url">
                  未命名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-12-11T10:55:52+08:00" content="2017-12-11">
              2017-12-11
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/12/11/Element-ui升级2.0后初体验/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/12/11/Element-ui升级2.0后初体验/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Element-ui升级2.0后初体验</p>
<p>如果你在使用Vue和Element-ui进行前端开发，那么就会知道Element在2017年10月27日升级到了2.0.0 Carbon的版本，改动可以说还是有些大的。可想而知，有的人选择按兵不动，有的人选择先睹为快。</p>
<p>现在打开Element-ui的官网，切换到1.4.12的文档，可以看到一个提示消息框：</p>
<blockquote>
<p>Element 1.x 已停止维护，请升级至 2.x</p>
</blockquote>
<p>所以还是建议尽早升级比较好，顺便也可以一起升级一下vue到2.5版本以上。下面我会介绍一些我在升级项目的过程中遇到的问题和需要注意的地方。</p>
<p>升级后的版本：<br>element-ui：2.0.4（最新版本已经到2.0.7）<br>vue：2.5.4</p>
<p>首先说一下整体印象，由于我做的这个项目是管理控制台类型的，升级后第一印象是页面变“白”了，也可以说变淡了，尤其是侧边栏、导航菜单，以前是可以选择深色的主题，现在没有这个<code>theme-default</code>预设了，新增了新的主题<code>chalk</code>，导致整个页面都是白白的。个人理解以后官方可能会出别的系列的主题，这样方便拆解和设计。<br>表格的表头原来也是有背景颜色区分的，现在的chalk主题下表头的颜色区分不是很明显。然后之前用的tag、按钮之类的都变大了，这是在什么都没设置，直接升级以后的第一眼效果。</p>
<p>然后下面说一下我遇到的需要修改的地方。</p>
<h4 id="1-引入的css文件路径变了"><a href="#1-引入的css文件路径变了" class="headerlink" title="1. 引入的css文件路径变了"></a>1. 引入的css文件路径变了</h4><p>原来是：<br><code>import &#39;element-ui/lib/theme-default/index.css&#39;</code><br>现在需要修改成：<br><code>import &#39;element-ui/lib/theme-chalk/index.css&#39;</code></p>
<h4 id="2-样式引入的优先级问题"><a href="#2-样式引入的优先级问题" class="headerlink" title="2. 样式引入的优先级问题"></a>2. 样式引入的优先级问题</h4><p>之前遇到这样一个问题，有的组件样式需要进行定制覆盖，于是就在组件里面用css scoped进行了同类名的样式替换，这样在开发环境下效果是符合预期的，但是打包编译后，优先级就变了。于是发现是在<code>main.js</code>引入文件路径顺序的问题，之前一度以为不需要顺序，但其实还是有影响的。</p>
<p>原来的配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></div><div class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></div><div class="line"><span class="keyword">import</span> ElementUI <span class="keyword">from</span> <span class="string">'element-ui'</span></div><div class="line"><span class="keyword">import</span> <span class="string">'element-ui/lib/theme-chalk/index.css'</span></div><div class="line"></div><div class="line">Vue.use(ElementUI)</div></pre></td></tr></table></figure>
<p>修改后的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></div><div class="line"><span class="keyword">import</span> ElementUI <span class="keyword">from</span> <span class="string">'element-ui'</span></div><div class="line"><span class="keyword">import</span> <span class="string">'element-ui/lib/theme-chalk/index.css'</span></div><div class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span> <span class="comment">//这里要把App的引用顺序放到最后</span></div><div class="line"></div><div class="line">Vue.use(ElementUI)</div></pre></td></tr></table></figure>
<h4 id="3-Icon的变化"><a href="#3-Icon的变化" class="headerlink" title="3. Icon的变化"></a>3. Icon的变化</h4><p>原来在<code>input</code>组件中可以用<code>icon</code>这个属性指定icon，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;el-input</div><div class="line">  icon=&quot;search&quot;&gt;</div><div class="line">&lt;/el-input&gt;</div></pre></td></tr></table></figure>
<p>现在的话，这样写是不生效的：</p>
<blockquote>
<p>可以通过<code>prefix-icon</code> 和 <code>suffix-icon</code> 属性在 input 组件首部和尾部增加显示图标，也可以通过 slot 来放置图标。</p>
</blockquote>
<p>所以如果你在项目中的<code>input</code>里用到了<code>icon</code>的属性，需要改成<code>prefix-icon</code> 或 <code>suffix-icon</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;el-input</div><div class="line">	suffix-icon=&quot;el-icon-search&quot;&gt;</div><div class="line">&lt;/el-input&gt;</div></pre></td></tr></table></figure>
<p>但是button组件就还是可以使用<code>icon</code>属性，但需要传入完整的图标类名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-search&quot;&gt;搜索&lt;/el-button&gt;</div></pre></td></tr></table></figure></p>
<p>原因是：</p>
<blockquote>
<p>为了方便使用第三方图标，Button 的 <code>icon</code> 属性、Input 的 <code>prefix-icon</code> 和 <code>suffix-icon</code> 属性、Steps 的 <code>icon</code> 属性现在需要传入完整的图标类名</p>
</blockquote>
<h4 id="4-modal的变化"><a href="#4-modal的变化" class="headerlink" title="4. modal的变化"></a>4. modal的变化</h4><p>之前给不需要宽度的modal设了<code>width: auto;</code>，这样如果里面内容为空的时候基本没有宽度，更新后，如果没有内容，默认会铺满整个屏幕。</p>
<h4 id="5-NavMenu-导航菜单"><a href="#5-NavMenu-导航菜单" class="headerlink" title="5. NavMenu 导航菜单"></a>5. NavMenu 导航菜单</h4><p>原来的menu是有两个样式供选择的，<code>theme</code>有两个可选值<code>light, dark</code>，现在没有这个属性了，默认就是chalk主题的白色，如果想要定制，需要另外设置。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
<th>类型</th>
<th>可选值</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>background-color</td>
<td>菜单的背景色（仅支持 hex 格式）</td>
<td>string</td>
<td>—</td>
<td>#ffffff</td>
</tr>
<tr>
<td>text-color</td>
<td>菜单的文字颜色（仅支持 hex 格式）</td>
<td>string</td>
<td>—</td>
<td>#409EFF</td>
</tr>
<tr>
<td>active-text-color</td>
<td>当前激活菜单的文字颜色（仅支持 hex 格式）</td>
<td>string</td>
<td>—</td>
<td>#409EFF</td>
</tr>
</tbody>
</table>
<p>但是这样设置会有弊端，如果项目经过定制样式改过主题颜色，那么这里就需要进行单独设置，而且还仅支持 hex 格式，这就需要计算出来颜色的具体值，而不能通过scss变量来控制。</p>
<h4 id="6-slot-scope"><a href="#6-slot-scope" class="headerlink" title="6. slot-scope"></a>6. slot-scope</h4><p>这其实是[vue在2.5.0里的变化][1]<br>把<code>scope</code>换成了<code>slop-scope</code><br>所以在element里面升级后，也把相应的用到scope的地方做修改就行了</p>
<h4 id="7-checkbox"><a href="#7-checkbox" class="headerlink" title="7. checkbox"></a>7. checkbox</h4><p>在更新后测试的时候发现checkbox挂了，于是查看，发现Checkbox Events的<code>change</code>事件的参数变了：</p>
<p>1.0:</p>
<p><img src="https://segmentfault.com/img/bVY0CM?w=854&amp;h=167" alt="clipboard.png"></p>
<p>2.0:</p>
<p><img src="https://segmentfault.com/img/bVY0CQ?w=905&amp;h=185" alt="clipboard.png"></p>
<p>所以，原来1.0判断change函数里面是这么写的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">handleCheckAllChange(event) &#123;</div><div class="line">    this.checkedCities = event.target.checked ? cityOptions : [];</div><div class="line">    this.isIndeterminate = false;</div><div class="line">  &#125;,</div></pre></td></tr></table></figure>
<p>2.0是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">handleCheckAllChange(val) &#123;</div><div class="line">    this.checkedCities = val ? cityOptions : [];</div><div class="line">    this.isIndeterminate = false;</div><div class="line">  &#125;,</div></pre></td></tr></table></figure>
<p>目前就是这么多，随着项目深入，可能还会遇到更多的问题和兼容版本的问题，我们可以共同探讨。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/15/怎样在vue项目下添加Eslint/" itemprop="url">
                  怎样在vue项目下添加Eslint
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-11-15T15:13:40+08:00" content="2017-11-15">
              2017-11-15
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/11/15/怎样在vue项目下添加Eslint/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/11/15/怎样在vue项目下添加Eslint/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简易搭建"><a href="#简易搭建" class="headerlink" title="简易搭建"></a>简易搭建</h2><p><a href="https://eslint.org/" target="_blank" rel="external">ESLint官网网址</a></p>
<p><a href="http://eslint.cn/" target="_blank" rel="external">ESLint中文官网</a></p>
<p>如果你是想在自己的项目里搭建ESLint，就可以按照官网的指示，</p>
<p>以全局安装举例，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g eslint</div></pre></td></tr></table></figure>
<p>然后初始化</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eslint --init</div></pre></td></tr></table></figure>
<p>它会问你一些问题，你可以按照你的喜好进行配置，我选的是popular下面的standard，生成的文件是js格式，那么就会创建出<code>eslintrc.js</code>文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line"><span class="string">"extends"</span>: <span class="string">"standard"</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>然后就可以简单的lint某个文件了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ eslint yourfile.js</div></pre></td></tr></table></figure>
<h2 id="在vue的项目里新添加ESLint"><a href="#在vue的项目里新添加ESLint" class="headerlink" title="在vue的项目里新添加ESLint"></a>在vue的项目里新添加ESLint</h2><p>有的时候，早期的时候，我们建立vue项目的时候，可能图简便，并没有初始化ESLint、单元测试等等模块，那么就需要后添加进去。</p>
<p>如果是现在新建一个项目，通过vue-cli的问答就可以轻松初始化ESLint的配置。</p>
<p>这里说一下怎样在老项目里新添加ESLint。</p>
<p>首先，我先用vue-cli创建了一个新项目，在初始化的时候，选择安装eslint，</p>
<p>选择standard规则，然后就生成了<code>eslintrc.js</code>，把生成的这个文件拷贝到要加ESlint的老项目里。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// https://eslint.org/docs/user-guide/configuring</span></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="comment">//默认情况下，ESLint 会在所有父级目录里寻找配置文件，一直到根目录。如果你想要你所有项目都遵循一个特定的约定时，这将会很有用，但有时候会导致意想不到的结果。为了将 ESLint 限制到一个特定的项目，在你项目根目录下的 package.json 文件或者 .eslintrc.* 文件里的 eslintConfig 字段下设置 "root": true。ESLint 一旦发现配置文件中有 "root": true，它就会停止在父级目录中寻找。</span></div><div class="line">  root: <span class="literal">true</span>,</div><div class="line">  <span class="attr">parser</span>: <span class="string">'babel-eslint'</span>,</div><div class="line">  <span class="attr">parserOptions</span>: &#123;</div><div class="line">    <span class="attr">sourceType</span>: <span class="string">'module'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">env</span>: &#123;</div><div class="line">    <span class="attr">browser</span>: <span class="literal">true</span>,</div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// https://github.com/standard/standard/blob/master/docs/RULES-en.md</span></div><div class="line">  extends: <span class="string">'standard'</span>,</div><div class="line">  <span class="comment">// required to lint *.vue files</span></div><div class="line">  plugins: [</div><div class="line">    <span class="string">'html'</span></div><div class="line">  ],</div><div class="line">  <span class="comment">// add your custom rules here</span></div><div class="line">  <span class="string">'rules'</span>: &#123;</div><div class="line">    <span class="comment">// allow paren-less arrow functions 要求箭头函数的参数使用圆括号</span></div><div class="line">    <span class="string">'arrow-parens'</span>: <span class="number">0</span>,</div><div class="line">    <span class="comment">// allow async-await 强制 generator 函数中 * 号周围使用一致的空格</span></div><div class="line">    <span class="string">'generator-star-spacing'</span>: <span class="number">0</span>,</div><div class="line">    <span class="comment">// allow debugger during development</span></div><div class="line">    <span class="string">'no-debugger'</span>: process.env.NODE_ENV === <span class="string">'production'</span> ? <span class="number">2</span> : <span class="number">0</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后找到<code>package.json</code>，把ESLint相关的依赖加进去（也可以一个一个进行安装，或者有更好的办法。。）</p>
<p><img src="file:///var/folders/tw/l4f5twr93wl5fcvpnrwd8nvr0000gp/T/WizNote/6ef8389b-88cf-4ee1-aa09-772bb5afb6f1/index_files/68513208.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&quot;babel-eslint&quot;: &quot;^7.1.1&quot;,   &quot;eslint&quot;: &quot;^3.19.0&quot;,</div><div class="line"></div><div class="line">&quot;eslint-friendly-formatter&quot;: &quot;^3.0.0&quot;,</div><div class="line">&quot;eslint-loader&quot;: &quot;^1.7.1&quot;,</div><div class="line">&quot;eslint-plugin-html&quot;: &quot;^3.0.0&quot;,</div><div class="line">&quot;eslint-config-standard&quot;: &quot;^10.2.1&quot;,</div><div class="line">&quot;eslint-plugin-promise&quot;: &quot;^3.4.0&quot;,</div><div class="line">&quot;eslint-plugin-standard&quot;: &quot;^3.0.1&quot;,</div><div class="line">&quot;eslint-plugin-import&quot;: &quot;^2.7.0&quot;,</div><div class="line">&quot;eslint-plugin-node&quot;: &quot;^5.2.0&quot;,</div></pre></td></tr></table></figure>
<p>然后在<code>webpack.base.conf.js</code>的rules里添加</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">       <span class="attr">test</span>: <span class="regexp">/\.(js|vue)$/</span>,</div><div class="line">       <span class="attr">loader</span>: <span class="string">'eslint-loader'</span>,</div><div class="line">       <span class="attr">enforce</span>: <span class="string">'pre'</span>,</div><div class="line">       <span class="attr">include</span>: [resolve(<span class="string">'src'</span>), resolve(<span class="string">'test'</span>)],</div><div class="line">       <span class="attr">options</span>: &#123;</div><div class="line">         <span class="attr">formatter</span>: <span class="built_in">require</span>(<span class="string">'eslint-friendly-formatter'</span>)</div><div class="line">       &#125;</div><div class="line">     &#125;,</div></pre></td></tr></table></figure>
<p>再<code>npm install</code>一下，应该就可以了。</p>
<p>这里的编辑器推荐用vscode，可以非常智能的显示出哪里出错，方便修改。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/26/雯子前端半月刊-201710下/" itemprop="url">
                  雯子前端半月刊-201710下
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-10-26T21:49:13+08:00" content="2017-10-26">
              2017-10-26
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/10/26/雯子前端半月刊-201710下/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/10/26/雯子前端半月刊-201710下/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>10月下旬有那么一周的某几天相对闲一些，看了一点东西，记录一下，本来以为有挺多，其实就这么点。。</p>
<ol>
<li><p><a href="https://github.com/twbs/bootstrap/releases/tag/v4.0.0-beta.2" target="_blank" rel="external">Bootstrap v4.0.0-beta.2</a> 发布了，虽然说基本上绝大多数前端都用过Bootstrap，但是又有多少是真正用透了的呢。对于我来说最想引入的是flex布局和Sass的定制样式。可以统一一波现在项目中的老旧样式。</p>
</li>
<li><p><a href="https://github.com/hakimel/reveal.js" target="_blank" rel="external">reveal.js</a>接触了一下，还没用，觉得用代码写，要都写在index.html中，要以html中内嵌markdown的格式，感觉有些怪怪的，不知道有没有大神好好地用过的。</p>
</li>
<li><p>学习了一遍Vue官方文档的<a href="https://cn.vuejs.org/v2/style-guide/" target="_blank" rel="external">风格指南</a>，有一些地方还是蛮有用的，比如以前对于props的定义都是行内的，其实都应该写成详细模式。</p>
<blockquote>
<p>细致的 prop 定义有两个好处：<br>•    它们写明了组件的 API，所以很容易看懂组件的用法；<br>•    在开发环境下，如果向一个组件提供格式不正确的 prop，Vue 将会告警，以帮助你捕获潜在的错误来源。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 更好的做法！</span></div><div class="line">props: &#123;</div><div class="line">  <span class="attr">status</span>: &#123;</div><div class="line">    <span class="attr">type</span>: <span class="built_in">String</span>,</div><div class="line">    <span class="attr">required</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">validator</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> [</div><div class="line">        <span class="string">'syncing'</span>,</div><div class="line">        <span class="string">'synced'</span>,</div><div class="line">        <span class="string">'version-conflict'</span>,</div><div class="line">        <span class="string">'error'</span></div><div class="line">      ].indexOf(value) !== <span class="number">-1</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而且这个文档中还有好多困扰我好久的命名规则的问题，如果你有同样的困扰，可以趁代码和组件没有太多的时候，优化一下整个项目，并记住且让整个团队也养成这些命名习惯。</p>
</li>
<li><p>css modules了解</p>
<p>阮一峰的教程：<a href="http://www.ruanyifeng.com/blog/2016/06/css_modules.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2016/06/css_modules.html</a></p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/01/vue源码项目/" itemprop="url">
                  vue源码项目
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-06-01T19:34:23+08:00" content="2017-06-01">
              2017-06-01
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/06/01/vue源码项目/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/06/01/vue源码项目/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><ul>
<li><strong><code>build</code></strong>: 包含构建相关的内置文件。在大多数情况下你不需要去动它们。然而，熟悉一下下面的文件可能会有帮助。</li>
<li><p><code>build/alias.js</code>: 所有的源码和测试用到的模块引入别名</p>
</li>
<li><p><code>build/config.js</code>: 包含<code>dist/</code>文件夹下面生成的所有文件文件的build配置。这个文件是dist文件夹的源文件生成入口。</p>
</li>
<li><p><strong><code>dist</code></strong>: 包含分发的构建文件。注意这个目录只会在一个release发布的时候才会更新；在development分支的最新变化不会实时反映出来。</p>
</li>
</ul>
<p>See <a href="https://github.com/vuejs/vue/blob/dev/dist/README.md" target="_blank" rel="external">dist/README.md</a> for more details on dist files.</p>
<ul>
<li><p><strong><code>flow</code></strong>: 包含类型声明，用的是 <a href="https://flowtype.org/" target="_blank" rel="external">Flow</a>. 这些声明都是<strong>全局</strong>加载的，所以你会看到它们在源码中类型注释的使用。</p>
</li>
<li><p><strong><code>packages</code></strong>: 包含 <code>vue-server-renderer</code> 和 <code>vue-template-compiler</code>,是分离的NPM包。它们都是从源码里自动生成的，并且与main <code>vue</code> package有着同样的版本。</p>
</li>
<li><p><strong><code>test</code></strong>: 包含所有的测试. The unit tests are written with <a href="http://jasmine.github.io/2.3/introduction.html" target="_blank" rel="external">Jasmine</a> and run with <a href="http://karma-runner.github.io/0.13/index.html" target="_blank" rel="external">Karma</a>. The e2e tests are written for and run with <a href="http://nightwatchjs.org/" target="_blank" rel="external">Nightwatch.js</a>.</p>
</li>
<li><p><strong><code>src</code></strong>: contains the source code, obviously. The codebase is written in ES2015 with <a href="https://flowtype.org/" target="_blank" rel="external">Flow</a> type annotations.</p>
<ul>
<li><p><strong><code>compiler</code></strong>: contains code for the template-to-render-function compiler.</p>
<p>The compiler consists of a parser (converts template strings to element ASTs), an optimizer (detects static trees for vdom render optimization), and a code generator (generate render function code from element ASTs). Note the codegen directly generates code strings from the element AST - it’s done this way for smaller code size because the compiler is shipped to the browser in the standalone build.</p>
</li>
<li><p><strong><code>core</code></strong>: contains universal, platform-agnostic runtime code.</p>
<p>The Vue 2.0 core is platform-agnostic - which means code inside <code>core</code> should be able to run in any JavaScript environment, be it the browser, Node.js, or an embedded JavaScript runtime in native applications.</p>
<ul>
<li><p><strong><code>observer</code></strong>: contains code related to the reactivity system.</p>
</li>
<li><p><strong><code>vdom</code></strong>: contains code related to vdom element creation and patching.</p>
</li>
<li><p><strong><code>instance</code></strong>: contains Vue instance constructor and prototype methods.</p>
</li>
<li><p><strong><code>global-api</code></strong>: as the name suggests.</p>
</li>
<li><p><strong><code>components</code></strong>: universal abstract components. Currently <code>keep-alive</code> is the only one.</p>
</li>
</ul>
</li>
<li><p><strong><code>server</code></strong>: contains code related to server-side rendering.</p>
</li>
<li><p><strong><code>platforms</code></strong>: contains platform-specific code.</p>
<p>Entry files for dist builds are located in their respective platform directory.</p>
<p>Each platform module contains three parts: <code>compiler</code>, <code>runtime</code> and <code>server</code>, corresponding to the three directories above. Each part contains platform-specific modules/utilities which are then imported and injected to the core counterparts in platform-specific entry files. For example, the code implementing the logic behind <code>v-bind:class</code> is in <code>platforms/web/runtime/modules/class.js</code> - which is imported in <code>entries/web-runtime.js</code> and used to create the browser-specific vdom patching function.</p>
</li>
<li><p><strong><code>sfc</code></strong>: contains single-file component (<code>*.vue</code> files) parsing logic. This is used in the <code>vue-template-compiler</code> package.</p>
</li>
<li><p><strong><code>shared</code></strong>: contains utilities shared across the entire codebase.</p>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/24/javascript高级程序设计笔记/" itemprop="url">
                  javascript高级程序设计笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-04-24T18:52:56+08:00" content="2017-04-24">
              2017-04-24
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/04/24/javascript高级程序设计笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/04/24/javascript高级程序设计笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第四章-变量、作用域和内存问题"><a href="#第四章-变量、作用域和内存问题" class="headerlink" title="第四章 变量、作用域和内存问题"></a>第四章 变量、作用域和内存问题</h2><h3 id="4-1-基本类型和引用类型"><a href="#4-1-基本类型和引用类型" class="headerlink" title="4.1 基本类型和引用类型"></a>4.1 基本类型和引用类型</h3><p>基本类型：Undefined, Null, Boolean, Number, String，按值访问，可以操作保存在变量中的实际值。</p>
<p>引用类型： 保存在内存中的对象，按引用访问。</p>
<p>如果从一个变量向另一个变量复制<strong>基本类型</strong>的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num1 = <span class="number">5</span>;</div><div class="line"><span class="keyword">var</span> num2 = num;</div></pre></td></tr></table></figure>
<p><img src="/images/4.1 复制基本类型值的过程.png" alt="4.1 复制基本类型值的过程"></p>
<p>当一个变量向另一个变量复制<strong>引用类型</strong>的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值得副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。</p>
<p><em>用我的话理解就是，引用类型的变量本体会存在堆中，而复制的是指向堆内存的指针，两个指针都指向一个堆内存，也就是引用了同一个对象。</em></p>
<p>指针指向对象，变量引用同一个对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line"><span class="keyword">var</span> obj2 = obj1;</div><div class="line">obj1.name = <span class="string">"Athena"</span>;</div><div class="line">alert(obj2.name); <span class="comment">//"Athena"</span></div></pre></td></tr></table></figure>
<p><img src="/images/4.2 保存在变量对象中的变量和保存在堆中的对象之间的关系.png" alt="4.2 保存在变量对象中的变量和保存在堆中的对象之间的关系"></p>
<p>ECMAScript中所有的参数都是按值传递的。举几个例子就一目了然了。</p>
<p>参数为对象的情况</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  obj.name = <span class="string">"Nicholas"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">setName(person);</div><div class="line">alert(person.name); <span class="comment">//"Nicholas"</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  obj.name = <span class="string">"Nicholas"</span>;</div><div class="line">  obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">  obj.name = <span class="string">"Greg"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">setName(person);</div><div class="line">alert(person.name); <span class="comment">//"Nicholas"</span></div></pre></td></tr></table></figure>
<h4 id="4-1-4-检测类型"><a href="#4-1-4-检测类型" class="headerlink" title="4.1.4 检测类型"></a>4.1.4 检测类型</h4><p>检测基本数据类型用typeof</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="string">"Nicholas"</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="literal">true</span>;</div><div class="line"><span class="keyword">var</span> i = <span class="number">22</span>;</div><div class="line"><span class="keyword">var</span> u;</div><div class="line"><span class="keyword">var</span> n = <span class="literal">null</span>;</div><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</div><div class="line"></div><div class="line">alert(<span class="keyword">typeof</span> s); <span class="comment">//string</span></div><div class="line">alert(<span class="keyword">typeof</span> b); <span class="comment">//boolean</span></div><div class="line">alert(<span class="keyword">typeof</span> i); <span class="comment">//number</span></div><div class="line">alert(<span class="keyword">typeof</span> u); <span class="comment">//undefined</span></div><div class="line">alert(<span class="keyword">typeof</span> n); <span class="comment">//Object</span></div><div class="line">alert(<span class="keyword">typeof</span> o); <span class="comment">//Object</span></div></pre></td></tr></table></figure>
<p>instanceof用来检测是什么类型的对象</p>
<p><code>result = variable instanceof constructor</code></p>
<h3 id="4-3-垃圾收集"><a href="#4-3-垃圾收集" class="headerlink" title="4.3 垃圾收集"></a>4.3 垃圾收集</h3><h4 id="4-3-1-标记清除（主流）"><a href="#4-3-1-标记清除（主流）" class="headerlink" title="4.3.1 标记清除（主流）"></a>4.3.1 标记清除（主流）</h4><p>javascript中最常用的垃圾收集方式。当变量进入环境时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”</p>
<p>思想是给当前不使用的值加上标记，然后再回收其内存</p>
<h4 id="4-3-2-引用计数（罕见-IE）"><a href="#4-3-2-引用计数（罕见-IE）" class="headerlink" title="4.3.2 引用计数（罕见 IE）"></a>4.3.2 引用计数（罕见 IE）</h4><h2 id="第五章-引用类型"><a href="#第五章-引用类型" class="headerlink" title="第五章 引用类型"></a>第五章 引用类型</h2><h3 id="5-1-Object类型"><a href="#5-1-Object类型" class="headerlink" title="5.1 Object类型"></a>5.1 Object类型</h3><p>创建有两种方式：</p>
<p>1) 使用new操作符后跟Object构造函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">person.name = <span class="string">"athena"</span>;</div><div class="line">person.age = <span class="number">26</span>;</div></pre></td></tr></table></figure>
<p>2) 使用对象字面量表示法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">"athena"</span>,</div><div class="line">  <span class="attr">age</span>: <span class="number">26</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也可以<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;&#125;;</div><div class="line">person.name = <span class="string">"athena"</span>;</div><div class="line">person.age = <span class="number">26</span>;</div></pre></td></tr></table></figure></p>
<p>然后再说花括号的问题。在js中，有表达式上下文（expression context）和语句上下文（statement context）。表达式上下文指的是能够返回一个值（表达式），语句上下文例如跟在if语句条件后面，表达一个语句块的开始。在这里花括号处于表达式上下文中，则表示对象字面量的开始。</p>
<p>在封装函数时，对象字面量可以用来传递大量可选参数，而对那些必需值使用命名参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayInfo</span> (<span class="params">args</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> args.age == <span class="string">"number"</span>) &#123;</div><div class="line">    output = args.age;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">displayInfo(&#123;</div><div class="line">  <span class="attr">age</span>: <span class="number">29</span> <span class="comment">//这个参数可选</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="5-2-Array类型"><a href="#5-2-Array类型" class="headerlink" title="5.2 Array类型"></a>5.2 Array类型</h3><p>两种创建方式</p>
<p>1) 使用Array构造函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line"><span class="keyword">var</span> colors = <span class="built_in">Array</span>(<span class="number">30</span>) <span class="comment">//这个方法不能用forEach 可以用原生的for循环</span></div><div class="line"><span class="keyword">var</span> colors = <span class="built_in">Array</span>(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>)</div></pre></td></tr></table></figure></p>
<p>2) 使用数组字面量表示法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [];</div><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]</div></pre></td></tr></table></figure>
<h4 id="5-2-1-检测数组"><a href="#5-2-1-检测数组" class="headerlink" title="5.2.1 检测数组"></a>5.2.1 检测数组</h4><p>对于一个网页，或者一个全局作用域而言，只有一个全局执行环境，使用<code>instanceof</code>操作符就可以：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</div><div class="line">  <span class="comment">//对数组执行某些操作</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的狗在函数。</p>
<p>所以ECMAScript5新增了<code>Array.isArray()</code>方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(value)) &#123;</div><div class="line">  <span class="comment">//对数组执行某些操作</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5-5-Function类型"><a href="#5-5-Function类型" class="headerlink" title="5.5 Function类型"></a>5.5 Function类型</h3><p><em>函数是对象，函数名是指针</em></p>
<p>使用不带圆括号的函数名是访问函数指针，而非调用函数</p>
<h4 id="函数声明提升"><a href="#函数声明提升" class="headerlink" title="函数声明提升"></a>函数声明提升</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alert(sum(<span class="number">10</span>, <span class="number">10</span>));</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/14/面试题整理/" itemprop="url">
                  面试题整理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-04-14T20:31:23+08:00" content="2017-04-14">
              2017-04-14
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/04/14/面试题整理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/04/14/面试题整理/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-new操作符具体做了什么"><a href="#1-new操作符具体做了什么" class="headerlink" title="1. new操作符具体做了什么"></a>1. new操作符具体做了什么</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"><span class="keyword">var</span> func = <span class="keyword">new</span> Func();</div></pre></td></tr></table></figure>
<p>new共经过了四个阶段</p>
<h4 id="1-创建一个空对象"><a href="#1-创建一个空对象" class="headerlink" title="1. 创建一个空对象"></a>1. 创建一个空对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</div></pre></td></tr></table></figure>
<h4 id="2-设置原型链"><a href="#2-设置原型链" class="headerlink" title="2. 设置原型链"></a>2. 设置原型链</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj.__proto__= Func.prototype;</div></pre></td></tr></table></figure>
<h4 id="3-让Func中的this指向obj，并执行Func的函数体。"><a href="#3-让Func中的this指向obj，并执行Func的函数体。" class="headerlink" title="3. 让Func中的this指向obj，并执行Func的函数体。"></a>3. 让Func中的this指向obj，并执行Func的函数体。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = Func.call(obj);</div></pre></td></tr></table></figure>
<h4 id="4-判断Func的返回值类型："><a href="#4-判断Func的返回值类型：" class="headerlink" title="4. 判断Func的返回值类型："></a>4. 判断Func的返回值类型：</h4><p>如果是值类型，返回obj。如果是引用类型，就返回这个引用类型的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span>(result) == <span class="string">"object"</span>) &#123;</div><div class="line">  func = result;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  func = obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后再贴出来<a href="http://www.jianshu.com/p/15ac7393bc1f" target="_blank" rel="external">波同学</a>的写法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 先一本正经的创建一个构造函数，其实该函数与普通函数并无区别</span></div><div class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 将构造函数以参数形式传入</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">New</span>(<span class="params">func</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 声明一个中间对象，该对象为最终返回的实例</span></div><div class="line">    <span class="keyword">var</span> res = &#123;&#125;;</div><div class="line">    <span class="keyword">if</span> (func.prototype !== <span class="literal">null</span>) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 将实例的原型指向构造函数的原型</span></div><div class="line">        res.__proto__ = func.prototype;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ret为构造函数执行的结果，这里通过apply，将构造函数内部的this指向修改为指向res，即为实例对象</span></div><div class="line">    <span class="keyword">var</span> ret = func.apply(res, <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>));</div><div class="line"></div><div class="line">    <span class="comment">// 当我们在构造函数中明确指定了返回对象时，那么new的执行结果就是该返回对象</span></div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">typeof</span> ret === <span class="string">"object"</span> || <span class="keyword">typeof</span> ret === <span class="string">"function"</span>) &amp;&amp; ret !== <span class="literal">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 如果没有明确指定返回对象，则默认返回res，这个res就是实例对象</span></div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 通过new声明创建实例，这里的p1，实际接收的正是new中返回的res</span></div><div class="line"><span class="keyword">var</span> p1 = New(Person, <span class="string">'tom'</span>, <span class="number">20</span>);</div><div class="line"><span class="built_in">console</span>.log(p1.getName());</div><div class="line"></div><div class="line"><span class="comment">// 当然，这里也可以判断出实例的类型了</span></div><div class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<h2 id="2-JQuery-中-fn-extend-函数的实现（实现核心代码即可）"><a href="#2-JQuery-中-fn-extend-函数的实现（实现核心代码即可）" class="headerlink" title="2. JQuery 中 $.fn.extend 函数的实现（实现核心代码即可）"></a>2. JQuery 中 $.fn.extend 函数的实现（实现核心代码即可）</h2><p><a href="https://segmentfault.com/a/1190000005895616" target="_blank" rel="external">参考一</a></p>
<h2 id="3-伪元素和伪类的区别"><a href="#3-伪元素和伪类的区别" class="headerlink" title="3. 伪元素和伪类的区别"></a>3. 伪元素和伪类的区别</h2><h3 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h3><p>伪类存在的意义是为了通过选择器找到那些不存在与DOM树中的信息以及不能被常规CSS选择器获取到的信息。</p>
<p>伪类由一个冒号:开头，冒号后面是伪类的名称和包含在圆括号中的可选参数。</p>
<p>任何常规选择器可以再任何位置使用伪类。伪类语法不区别大小写。一些伪类的作用会互斥，另外一些伪类可以同时被同一个元素使用。并且，为了满足用户在操作DOM时产生的DOM结构改变，伪类也可以是动态的。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes" target="_blank" rel="external">标准伪类索引</a></p>
<p>:active<br>:any<br>:checked<br>:default<br>:dir()<br>:disabled<br>:empty<br>:enabled<br>:first<br>:first-child<br>:first-of-type<br>:fullscreen<br>:focus<br>:hover<br>:indeterminate<br>:in-range<br>:invalid<br>:lang()<br>:last-child<br>:last-of-type<br>:left<br>:link<br>:not()<br>:nth-child()<br>:nth-last-child()<br>:nth-last-of-type()<br>:nth-of-type()<br>:only-child<br>:only-of-type<br>:optional<br>:out-of-range<br>:read-only<br>:read-write<br>:required<br>:right<br>:root<br>:scope<br>:target<br>:valid<br>:visited</p>
<h3 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h3><p>伪元素在DOM树中创建了一些抽象元素，这些抽象元素是不存在于文档语言里的（可以理解为html源码）。比如：documen接口不提供访问元素内容的第一个字或者第一行的机制，而伪元素可以使开发者可以提取到这些信息。并且，一些伪元素可以使开发者获取到不存在于源文档中的内容（比如常见的::before,::after）。</p>
<p>伪元素的由两个冒号::开头，然后是伪元素的名称。</p>
<p>使用两个冒号::是为了区别伪类和伪元素（CSS2中并没有区别）。当然，考虑到兼容性，CSS2中已存的伪元素仍然可以使用一个冒号:的语法，但是CSS3中新增的伪元素必须使用两个冒号::。</p>
<p>一个选择器只能使用一个伪元素，并且伪元素必须处于选择器语句的最后。</p>
<p>注：不排除未来会加入同时使用多个伪元素的机制。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-elements" target="_blank" rel="external">所有伪元素</a></p>
<p>::after<br>::before<br>::first-letter<br>::first-line<br>::selection</p>
<h2 id="4-找出整形数组中乘积最大的三个数"><a href="#4-找出整形数组中乘积最大的三个数" class="headerlink" title="4. 找出整形数组中乘积最大的三个数"></a>4. 找出整形数组中乘积最大的三个数</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/11/你不知道的js笔记-this和原型/" itemprop="url">
                  你不知道的js笔记-this和原型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-04-11T11:06:01+08:00" content="2017-04-11">
              2017-04-11
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/04/11/你不知道的js笔记-this和原型/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/04/11/你不知道的js笔记-this和原型/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="this的调用"><a href="#this的调用" class="headerlink" title="this的调用"></a>this的调用</h2><p>每个函数的this是在调用时被绑定的，完全取决于函数的调用位置，也就是函数的调用方法。<br>那么就要分析调用栈，可以用浏览器的调试工具查看调用栈。打断点后，显示的调用栈的第二个元素，就是真正的调用位置。</p>
<h3 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h3><h4 id="1-默认绑定"><a href="#1-默认绑定" class="headerlink" title="1. 默认绑定"></a>1. 默认绑定</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">funciton foo()&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line">foo(); <span class="comment">//2</span></div></pre></td></tr></table></figure>
<p>如果使用严格模式，则不能将全局对象用于默认绑定，因此this会绑定到undefined</p>
<h4 id="2-隐式绑定"><a href="#2-隐式绑定" class="headerlink" title="2. 隐式绑定"></a>2. 隐式绑定</h4><p>在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把this间接（隐式）绑定到这个对象上。<br>当函数引用有上下文对象时，隐式绑定规则会把函数调用中的this绑定到这个上下文对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">funciton foo() &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">2</span>,</div><div class="line">  <span class="attr">foo</span>: foo</div><div class="line">&#125;;</div><div class="line"></div><div class="line">obj.foo(); <span class="comment">//2</span></div></pre></td></tr></table></figure>
<h4 id="3-显式绑定"><a href="#3-显式绑定" class="headerlink" title="3. 显式绑定"></a>3. 显式绑定</h4><p>call(…)和apply(…)<br>它们的第一个参数是一个对象，是给this准备的，接着在调用函数时将其绑定到this。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">funciton foo() &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">a</span>:<span class="number">2</span></div><div class="line">&#125;;</div><div class="line">foo.call(obj); <span class="comment">//2</span></div></pre></td></tr></table></figure>
<p>如果传入了一个原始值，也就是字符串类型、布尔类型或者数字类型来当做this的绑定对象，这个原始值会被转换成它的对象形式，也就是new String(…), new Boolean(…), new Number(…)</p>
<h5 id="3-1-硬绑定"><a href="#3-1-硬绑定" class="headerlink" title="3.1 硬绑定"></a>3.1 硬绑定</h5><p>ES5提供了内置的方法Function.prototype.bind，它的用法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a, something);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.a + something;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">a</span>:<span class="number">2</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> bar = foo.bind(obj);</div><div class="line"></div><div class="line"><span class="keyword">var</span> b = bar (<span class="number">3</span>); <span class="comment">//2 3</span></div><div class="line"><span class="built_in">console</span>.log(b); <span class="comment">//5</span></div></pre></td></tr></table></figure>
<p>bind会返回一个硬解码的新函数，它会把你指定的参数设置为this的上下文并调用原始函数。</p>
<h5 id="3-2-API调用的上下文"><a href="#3-2-API调用的上下文" class="headerlink" title="3.2 API调用的上下文"></a>3.2 API调用的上下文</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">fonction foo(el) &#123;</div><div class="line">  <span class="built_in">console</span>.log(el, <span class="keyword">this</span>.id);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">id</span>: <span class="string">"awesome"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//调用foo(...)时把this绑定到obj</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach(foo, obj)</div></pre></td></tr></table></figure>
<h4 id="4-new绑定"><a href="#4-new绑定" class="headerlink" title="4. new绑定"></a>4. new绑定</h4>
          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/10/你不知道的js第五章笔记/" itemprop="url">
                  你不知道的js第五章笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-04-10T11:06:56+08:00" content="2017-04-10">
              2017-04-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/04/10/你不知道的js第五章笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/04/10/你不知道的js第五章笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="作用域闭包"><a href="#作用域闭包" class="headerlink" title="作用域闭包"></a>作用域闭包</h2><p>首先是闭包的定义：</p>
<blockquote>
<p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。</p>
</blockquote>
<p>无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包。</p>
<p>本质上无论何时何地，如果将（访问它们各自词法作用域的）函数当做第一级的值类型并到处传递，就会看到闭包在这些函数的应用。例如定时器、事件监听器、ajax请求、跨窗口通信等，只要使用了毁掉函数，实际上就是在使用闭包。</p>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>模块模式需要具备两个必要条件：</p>
<ol>
<li>必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）</li>
<li>封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。</li>
</ol>
<p>es6的模块没有“行内”格式，必须被定义在独立的文件中，即一个文件一个模块。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/13/你不知道的js第二章笔记/" itemprop="url">
                  你不知道的js第二章笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-03-13T11:02:42+08:00" content="2017-03-13">
              2017-03-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/03/13/你不知道的js第二章笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/13/你不知道的js第二章笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第二章-词法作用域"><a href="#第二章-词法作用域" class="headerlink" title="第二章 词法作用域"></a>第二章 词法作用域</h2><p>作用域一般有两种模型，一种是词法作用域，是大多数包括js使用的，另一种是动态作用域，如bash脚本之类的。</p>
<h3 id="2-1-词法阶段"><a href="#2-1-词法阶段" class="headerlink" title="2.1 词法阶段"></a>2.1 词法阶段</h3>
          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/11/你不知道的js第一章笔记-1/" itemprop="url">
                  你不知道的js第一章笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-03-11T18:30:23+08:00" content="2017-03-11">
              2017-03-11
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/03/11/你不知道的js第一章笔记-1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/11/你不知道的js第一章笔记-1/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-1-编译原理"><a href="#1-1-编译原理" class="headerlink" title="1.1 编译原理"></a>1.1 编译原理</h2><p>传统编译语言一般会经历以下三个流程：</p>
<h3 id="分词-词法分析"><a href="#分词-词法分析" class="headerlink" title="分词/词法分析"></a>分词/词法分析</h3><p>生成词法单元</p>
<h3 id="解析-语法分析"><a href="#解析-语法分析" class="headerlink" title="解析/语法分析"></a>解析/语法分析</h3><p>将词法单元转换成抽象语法树</p>
<h3 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h3><p>将抽象语法树转换成可执行代码</p>
<p>对于js来说，编译基本发生在代码执行前的几微秒的时间内，也就是在执行前编译，编译完马上执行。</p>
<h2 id="1-2-理解作用域"><a href="#1-2-理解作用域" class="headerlink" title="1.2 理解作用域"></a>1.2 理解作用域</h2><p>首先是说处理代码的时候，有三个东西，分别是引擎、编译器和作用域。</p>
<p>首先编译器要先进行上一节说到的词法分析和语法分析，然后去作用域查询这个变量是否存在，然后为引擎生成执行代码</p>
<p>然后就遇到了LHS和RHS查询，查了一下就是left-hand-side和right-hand-side，就是左手边和右手边的意思。当变量出现在哪侧就执行哪侧的查询。<br>LHS就是查找变量容器本身，也就是赋值操作的目标是谁。<br>RHS就是简单的查找某个变量的值，也就是谁是赋值操作的源头。<br>如果查找的目的是对变量进行赋值，那么就会使用LHS查询；如果目的是获取变量的值，就会使用RHS查询。<br>LHS和RHS查询都会一层层的向上查找作用域，如果RHS不成功会抛出异常，如果LHS不成功，在非严格模式下会自动隐式的创建一个全局变量，严格模式下会抛出异常。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="Athena Ou" />
          <p class="site-author-name" itemprop="name">Athena Ou</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">17</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Athena Ou</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=0.5.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"athena0304"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  

  


</body>
</html>
