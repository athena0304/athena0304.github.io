<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.2" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.2">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.2" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.4.2',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="Athena">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Athena">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Athena">






  <link rel="canonical" href="http://yoursite.com/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Athena</title>
  






  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?15fcb8c2aa27ecb358060d2600aa2502";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Athena</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">雯子写字的地方</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    
  
  
  
    
      
    
    <a href="https://github.com/athena0304" class="github-corner" target="_blank" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#222; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg>
    
      </a>
    



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/29/addEventListener/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雯子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Athena">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/29/addEventListener/" itemprop="url">
                  一个由addEventListener参数问题所引发的阅读
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-29 21:21:31" itemprop="dateCreated datePublished" datetime="2018-10-29T21:21:31+08:00">2018-10-29</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-10-31 23:03:46" itemprop="dateModified" datetime="2018-10-31T23:03:46+08:00">2018-10-31</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天我在看一篇讲MVC和观察者模式的文章的时候，里面有一个例子代码，是这样的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(model) &#123;</span><br><span class="line">    <span class="keyword">this</span>.model = model;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//EVENTLISTENER INTERFACE</span></span><br><span class="line">  handleEvent(e) &#123;</span><br><span class="line">    e.stopPropagation();</span><br><span class="line">    <span class="keyword">switch</span> (e.type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"click"</span>:</span><br><span class="line">        <span class="keyword">this</span>.clickHandler(e.target);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">console</span>.log(e.target);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//GET MODEL HEADING</span></span><br><span class="line">  getModelHeading() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.model.heading;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//CHANGE THE MODEL</span></span><br><span class="line">  clickHandler(target) &#123;</span><br><span class="line">    <span class="keyword">this</span>.model.heading = <span class="string">"World"</span>;</span><br><span class="line">    <span class="keyword">this</span>.model.notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>中间实例化了这个class，为controller<br>DOM事件监听的调用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.heading.addEventListener(<span class="string">"click"</span>, controller);</span><br></pre></td></tr></table></figure></p>
<p>可以发现，这里的addEventListener传的第二个参数是一个对象，那么这个对象怎么就能解析事件呢，以前的我只知道第二个参数应该传一个函数，而从没使用过对象的这种方式。于是查了一下MDN，果然不简单。</p>
<h2 id="EventTarget"><a href="#EventTarget" class="headerlink" title="EventTarget"></a>EventTarget</h2><p>要说 addEventListener，首先要从 <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget" target="_blank" rel="noopener">EventTarget</a> 说起。</p>
<blockquote>
<p>EventTarget 是一个由对象实现的接口，这些对象可以接收事件，并为它们提供侦听器。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element" target="_blank" rel="noopener"><code>Element</code></a>、 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document" target="_blank" rel="noopener"><code>document</code></a>和 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window" target="_blank" rel="noopener"><code>window</code></a> 是最常见的 event targets, 但其它对象也可成为 event targets， 例如 <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener"><code>XMLHttpRequest</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/API/AudioNode" target="_blank" rel="noopener"><code>AudioNode</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/API/AudioContext" target="_blank" rel="noopener"><code>AudioContext</code></a> 等。</p>
<p>Web平台提供了几种获取DOM事件通知的方法。两种常见的方式是：通用 <code>addEventListener()</code> 和一组特定的 <strong>on-event</strong> 处理程序。</p>
</blockquote>
<p>然后 MDN 给出了一个 EventTarget 的简单实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventTarget = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.listeners = &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EventTarget.prototype.listeners = <span class="literal">null</span>;</span><br><span class="line">EventTarget.prototype.addEventListener = <span class="function"><span class="keyword">function</span>(<span class="params">type, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(type <span class="keyword">in</span> <span class="keyword">this</span>.listeners)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.listeners[type] = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.listeners[type].push(callback);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EventTarget.prototype.removeEventListener = <span class="function"><span class="keyword">function</span>(<span class="params">type, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(type <span class="keyword">in</span> <span class="keyword">this</span>.listeners)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> stack = <span class="keyword">this</span>.listeners[type];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = stack.length; i &lt; l; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (stack[i] === callback)&#123;</span><br><span class="line">      stack.splice(i, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EventTarget.prototype.dispatchEvent = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(event.type <span class="keyword">in</span> <span class="keyword">this</span>.listeners)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> stack = <span class="keyword">this</span>.listeners[event.type].slice();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = stack.length; i &lt; l; i++) &#123;</span><br><span class="line">    stack[i].call(<span class="keyword">this</span>, event);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> !event.defaultPrevented;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我这一看，这不就是这几天正在研究的观察者模式么，EventTarget 是一个构造函数，是被观察的主体，在原型上绑定了三个方法：</p>
<ul>
<li><code>addEventListener()</code> - 在 EventTarget 上注册特定事件类型的事件处理程序。</li>
<li><code>removeEventListener()</code> - 从 EventTarget 中删除一个事件侦听器。</li>
<li><code>dispatchEvent()</code> - 将事件分派到此 EventTarget。</li>
</ul>
<p>其中的 listener 就是监听的事件，类型和回调函数。</p>
<h2 id="EventListener"><a href="#EventListener" class="headerlink" title="EventListener"></a>EventListener</h2><p>接下来，我们再来看 <strong><a href="https://developer.mozilla.org/en-US/docs/Web/API/EventListener" target="_blank" rel="noopener">EventListener</a></strong></p>
<blockquote>
<p>EventListener 接口表示一个对象，可以处理 EventTarget 对象发出的事件。</p>
<p>由于需要与遗留内容兼容，EventListener 接受一个函数，或者带有 handleEvent() 属性函数的对象。如下例所示。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span>&gt;</span>Click here!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buttonElement = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过提供回调函数为'click'事件添加处理程序。</span></span><br><span class="line"><span class="comment">// Whenever the element is clicked, a pop-up with "Element clicked!" will</span></span><br><span class="line"><span class="comment">// appear.</span></span><br><span class="line">buttonElement.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'Element clicked through function!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// For compatibility, a non-function object with a `handleEvent` property is</span></span><br><span class="line"><span class="comment">// treated just the same as a function itself.</span></span><br><span class="line">buttonElement.addEventListener(<span class="string">'click'</span>, &#123;</span><br><span class="line">  handleEvent: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Element clicked through handleEvent property!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里我们看到一开始抛出的，addEventListener 的第二个参数可以是一个对象，里面有一个函数属性，名字为 <code>handleEvent</code>。</p>
<p>按理说这篇文章到这，就差不多了，但是我发现好多跟 <code>addEventListener</code> 相关的东西，于是再进一步探索一下。</p>
<h2 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener"></a>addEventListener</h2><p>先列一下语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target.addEventListener(type, listener[, options]);</span><br><span class="line">target.addEventListener(type, listener[, useCapture]);</span><br><span class="line">target.addEventListener(type, listener[, useCapture, wantsUntrusted  ]); // Gecko/Mozilla only</span><br></pre></td></tr></table></figure>
<p>再看一下每个参数：</p>
<ul>
<li><p>type-表示要侦听的事件类型，是一个大小写敏感的字符串</p>
</li>
<li><p>listener - 当发生指定类型的事件时接收通知（实现 Event 接口的对象）的对象。这必须是实现 EventListener 接口的对象，或 JavaScript 函数。</p>
</li>
<li><p>options</p>
<p>指定事件侦听器特征的选项对象。可用的选项如下：</p>
<ul>
<li><code>capture</code>:  <code>Boolean</code>，表示 <code>listener</code> 会在该类型的事件捕获阶段传播到该 <code>EventTarget</code> 时触发。</li>
<li><code>once</code>:  <code>Boolean</code>，表示 <code>listener 在添加之后最多只调用一次。如果是</code> <code>true，</code> <code>listener</code> 会在其被调用之后自动移除。</li>
<li><code>passive</code>: <code>Boolean</code>，如果为真，则表示 <code>listener</code> 永远不会调用 <code>preventDefault()。如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告。</code></li>
<li><code>mozSystemGroup</code>: 只能在 XBL 或者是 Firefox’ chrome 使用，这是个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Boolean" target="_blank" rel="noopener"><code>Boolean</code></a>，表示 <code>listener</code>被添加到 system group。</li>
</ul>
</li>
</ul>
<p>在说到第三个参数的时候，就必须了解 DOM 的事件流，这里我们从W3C工作草案 <a href="http://www.w3.org/TR/DOM-Level-3-Events/#event-flow" target="_blank" rel="noopener">DOM Level 3 Events</a> 开始了解。</p>
<ul>
<li><p>useCapture</p>
<p>一个布尔值，默认为false。指示在将此类型的事件分派到DOM树中它下面的任何EventTarget之前，是否会将此类型的事件分派给已注册的侦听器。通过树向上冒泡的事件不会触发指定使用捕获的侦听器。当两个元素都为该事件注册了句柄时，事件冒泡和捕获是传播在嵌套在另一个元素中的元素中发生的事件的两种方法。事件传播模式确定元素接收事件的顺序。</p>
</li>
</ul>
<h2 id="DOM-Event-Architecture"><a href="#DOM-Event-Architecture" class="headerlink" title="DOM Event Architecture"></a>DOM Event Architecture</h2><h3 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h3><p>在看规范正文之前，不得不说，还得看一下一些术语和翻译的对应，不然用以被这些名字搞懵。</p>
<h4 id="Event-事件"><a href="#Event-事件" class="headerlink" title="Event-事件"></a>Event-事件</h4><p>看一下<a href="https://dom.spec.whatwg.org/#interface-event" target="_blank" rel="noopener">接口描述</a>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[Constructor(DOMString type, optional EventInit eventInitDict),</span><br><span class="line"> Exposed=(Window,Worker,AudioWorklet)]</span><br><span class="line">interface Event &#123;</span><br><span class="line">  readonly attribute DOMString type;</span><br><span class="line">  readonly attribute EventTarget? target;</span><br><span class="line">  readonly attribute EventTarget? srcElement; // historical</span><br><span class="line">  readonly attribute EventTarget? currentTarget;</span><br><span class="line">  sequence&lt;EventTarget&gt; composedPath();</span><br><span class="line"></span><br><span class="line">  const unsigned short NONE = 0;</span><br><span class="line">  const unsigned short CAPTURING_PHASE = 1;</span><br><span class="line">  const unsigned short AT_TARGET = 2;</span><br><span class="line">  const unsigned short BUBBLING_PHASE = 3;</span><br><span class="line">  readonly attribute unsigned short eventPhase;</span><br><span class="line"></span><br><span class="line">  void stopPropagation();</span><br><span class="line">           attribute boolean cancelBubble; // historical alias of .stopPropagation</span><br><span class="line">  void stopImmediatePropagation();</span><br><span class="line"></span><br><span class="line">  readonly attribute boolean bubbles;</span><br><span class="line">  readonly attribute boolean cancelable;</span><br><span class="line">           attribute boolean returnValue;  // historical</span><br><span class="line">  void preventDefault();</span><br><span class="line">  readonly attribute boolean defaultPrevented;</span><br><span class="line">  readonly attribute boolean composed;</span><br><span class="line"></span><br><span class="line">  [Unforgeable] readonly attribute boolean isTrusted;</span><br><span class="line">  readonly attribute DOMHighResTimeStamp timeStamp;</span><br><span class="line"></span><br><span class="line">  void initEvent(DOMString type, optional boolean bubbles = false, optional boolean cancelable = false); // historical</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">dictionary EventInit &#123;</span><br><span class="line">  boolean bubbles = false;</span><br><span class="line">  boolean cancelable = false;</span><br><span class="line">  boolean composed = false;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>事件对象简单地称为事件。它允许发送发生了什么事情的信号，例如，图像已经完成下载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event = new Event(type [, eventInitDict])</span><br></pre></td></tr></table></figure>
<p>返回一个新事件，其 <code>type</code> 属性值设置为 type。eventInitDictargument 允许通过同名对象成员设置 <code>bubbles</code> 和 <code>cancelable</code> 属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event . type</span><br></pre></td></tr></table></figure>
<p>返回事件的类型， e.g. “<code>click</code>“, “<code>hashchange</code>“, or “<code>submit</code>“.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event . target</span><br></pre></td></tr></table></figure>
<p>返回发送事件的对象(其目标)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event . currentTarget</span><br></pre></td></tr></table></figure>
<p>返回当前正在调用其事件侦听器回调的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event . composedPath()</span><br></pre></td></tr></table></figure>
<p>Returns the <a href="https://dom.spec.whatwg.org/#event-path-item" target="_blank" rel="noopener">item</a> objects of event’s <a href="https://dom.spec.whatwg.org/#event-path" target="_blank" rel="noopener">path</a> (objects on which listeners will be invoked), except for any <a href="https://dom.spec.whatwg.org/#concept-node" target="_blank" rel="noopener">nodes</a> in <a href="https://dom.spec.whatwg.org/#concept-shadow-tree" target="_blank" rel="noopener">shadow trees</a> of which the <a href="https://dom.spec.whatwg.org/#concept-shadow-root" target="_blank" rel="noopener">shadow root</a>’s <a href="https://dom.spec.whatwg.org/#shadowroot-mode" target="_blank" rel="noopener">mode</a> is “<code>closed</code>“ that are not reachable from event’s <code>currentTarget</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event . eventPhase</span><br></pre></td></tr></table></figure>
<p>Returns the <a href="https://dom.spec.whatwg.org/#concept-event" target="_blank" rel="noopener">event</a>’s phase, which is one of <code>NONE</code>, <code>CAPTURING_PHASE</code>, <code>AT_TARGET</code>, and <code>BUBBLING_PHASE</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event . stopPropagation()</span><br></pre></td></tr></table></figure>
<p>在树中分派时，调用此方法可防止事件到达当前对象以外的任何对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event . stopImmediatePropagation()</span><br></pre></td></tr></table></figure>
<p>Invoking this method prevents event from reaching any registered <a href="https://dom.spec.whatwg.org/#concept-event-listener" target="_blank" rel="noopener">event listeners</a> after the current one finishes running and, when <a href="https://dom.spec.whatwg.org/#concept-event-dispatch" target="_blank" rel="noopener">dispatched</a> in a <a href="https://dom.spec.whatwg.org/#concept-tree" target="_blank" rel="noopener">tree</a>, also prevents eventfrom reaching any other objects.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event . bubbles</span><br></pre></td></tr></table></figure>
<p>根据事件初始化的方式返回 true 或 false。如果事件以相反的树顺序通过目标的祖先，则为真，否则为假。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event . cancelable</span><br></pre></td></tr></table></figure>
<p>根据事件初始化的方式返回 true 或 false。它的返回值并不总是有意义，但是 true 可以指示在事件被分派期间，可以通过调用 preventDefault() 方法来取消部分操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event . preventDefault()</span><br></pre></td></tr></table></figure>
<p>If invoked when the <code>cancelable</code> attribute value is true, and while executing a listener for the event with <code>passive</code> set to false, signals to the operation that caused event to be <a href="https://dom.spec.whatwg.org/#concept-event-dispatch" target="_blank" rel="noopener">dispatched</a> that it needs to be canceled.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event . defaultPrevented</span><br></pre></td></tr></table></figure>
<p>Returns true if <code>preventDefault()</code> was invoked successfully to indicate cancelation, and false otherwise.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event . composed</span><br></pre></td></tr></table></figure>
<p>Returns true or false depending on how event was initialized. True if event invokes listeners past a <code>ShadowRoot</code> <a href="https://dom.spec.whatwg.org/#boundary-point-node" target="_blank" rel="noopener">node</a> that is the <a href="https://dom.spec.whatwg.org/#concept-tree-root" target="_blank" rel="noopener">root</a> of its <a href="https://dom.spec.whatwg.org/#event-target" target="_blank" rel="noopener">target</a>, and false otherwise.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event . isTrusted</span><br></pre></td></tr></table></figure>
<p>Returns true if event was <a href="https://dom.spec.whatwg.org/#concept-event-dispatch" target="_blank" rel="noopener">dispatched</a> by the user agent, and false otherwise.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event . timeStamp</span><br></pre></td></tr></table></figure>
<p>Returns the event’s timestamp as the number of milliseconds measured relative to the <a href="https://w3c.github.io/hr-time/#dfn-time-origin" target="_blank" rel="noopener">time origin</a>.</p>
<h4 id="dispatch-分派、派发、分发"><a href="#dispatch-分派、派发、分发" class="headerlink" title="dispatch-分派、派发、分发"></a><a href="https://www.w3.org/TR/DOM-Level-3-Events/#dispatch" target="_blank" rel="noopener">dispatch</a>-分派、派发、分发</h4><p>创建一个事件，该事件具有与其类型和上下文相匹配的属性和方法，并以指定的方式通过DOM树进行传播。可以与术语 fire 互换，例如，触发一个单击事件（fire a click event）或分派一个加载事件（dispatch a load event）。</p>
<h4 id="event-target-事件目标"><a href="#event-target-事件目标" class="headerlink" title="event target-事件目标"></a><a href="https://www.w3.org/TR/DOM-Level-3-Events/#event-target" target="_blank" rel="noopener">event target</a>-事件目标</h4><p>事件的目标对象，使用事件派发和DOM事件流。<strong>事件目标</strong>是 event 的 target 属性的值。也就是 event.target。</p>
<h4 id="propagation-path-传播路径"><a href="#propagation-path-传播路径" class="headerlink" title="propagation path-传播路径"></a><a href="https://www.w3.org/TR/DOM-Level-3-Events/#propagation-path" target="_blank" rel="noopener">propagation path</a>-传播路径</h4><p><strong>当前事件目标</strong>的有序集合，事件对象将在进出事件目标的过程中按顺序传递。当事件传播时，<strong>传播路径</strong>中的每个当前事件目标依次设置为currentTarget。<strong>传播路径</strong>最初由事件类型定义的一个或多个事件阶段组成，但可能会被中断。也称为事件目标链。</p>
<h4 id="current-event-target-当前事件目标"><a href="#current-event-target-当前事件目标" class="headerlink" title="current event target-当前事件目标"></a><a href="https://www.w3.org/TR/DOM-Level-3-Events/#current-event-target" target="_blank" rel="noopener">current event target</a>-当前事件目标</h4><p>在事件流中，<strong>当前事件目标</strong>是与当前派发的事件处理程序关联的对象。此对象可能是目标事件本身或其祖先之一。当事件通过事件流的各个阶段从一个对象传播到另一个对象时，<strong>当前事件目标</strong>会发生变化。<strong>当前事件目标</strong>是 currentTarget 属性的值。</p>
<h4 id="event-handler-event-listener-事件处理程序-事件侦听器"><a href="#event-handler-event-listener-事件处理程序-事件侦听器" class="headerlink" title="event handler/event listener-事件处理程序/事件侦听器"></a><a href="https://www.w3.org/TR/DOM-Level-3-Events/#event-handler" target="_blank" rel="noopener">event handler/event listener</a>-事件处理程序/事件侦听器</h4><p>实现EventListener接口并提供handleEvent()回调方法的对象。事件处理程序是特定于语言的。事件处理程序在特定对象(<strong>当前事件目标</strong>)的上下文中调用，并提供事件对象本身。</p>
<h4 id="phase-阶段"><a href="#phase-阶段" class="headerlink" title="phase-阶段"></a>phase-阶段</h4><p>在事件的上下文中，阶段是一组沿着DOM树的逻辑遍历，从 Window 到 <code>Document</code> 对象、根元素，然后下到事件对象（捕获阶段），再到事件对象本身（目标阶段），然后沿原路返回（冒泡阶段）。</p>
<h3 id="事件分发和DOM事件流-Event-dispatch-and-DOM-event-flow"><a href="#事件分发和DOM事件流-Event-dispatch-and-DOM-event-flow" class="headerlink" title="事件分发和DOM事件流-Event dispatch and DOM event flow"></a>事件分发和DOM事件流-Event dispatch and DOM event flow</h3><p>本章节会简单介绍<strong>事件分派</strong>机制，并描述事件是如何通过DOM树进行传播的。应用程序可以使用 <code>dispatchEvent()</code> 方法分派事件对象，事件对象将通过DOM事件流确定的DOM树传播。</p>
<p><img src="https://www.w3.org/TR/DOM-Level-3-Events/images/eventflow.svg" alt="Graphical representation of an event dispatched in a DOM tree using the DOM event flow"></p>
<p>事件对象被分发到一个<strong>事件目标</strong>上。但是在开始分派之前，必须先确定事件对象的<strong>传播路径</strong>。</p>
<p><strong>传播路径</strong>是事件通过<strong>当前事件目标</strong>的有序列表。这个传播路径反映了文档的层次树结构。列表中的最后一项是<strong>事件目标</strong>，在这之前的都称为目标的祖先项，挨着事件目标的称作目标的父项。</p>
<p>一旦传播路径决定了，事件对象就会经过一个或多个<strong>事件阶段</strong>。有三个事件阶段：捕获阶段、目标阶段和冒泡阶段。事件对象会像下面描述的这样来完成这些阶段。如果不支持某个阶段，或者事件对象的传播已经停止，则跳过该阶段。例如，如果 <code>bubbles</code> 属性设成了 false，就会跳过冒泡阶段，如果在分派之前就调用了 <code>stopPropagation()</code>，所有阶段都会被跳过。</p>
<ul>
<li><p>捕获阶段（capture phase）：事件对象通过对象的祖先项，从 Window 传播到目标的父项。该阶段也被称为 capturing phase （反正中文翻译过来都是捕获阶段）</p>
</li>
<li><p>目标阶段（target phase）：事件对象到达事件对象的事件目标上面。该阶段也被称作 at-target phase （反正翻译过来还是目标阶段）。如果事件类型指出该事件不进行冒泡，则事件对象将在此阶段结束后停止。</p>
</li>
<li>冒泡阶段（bubble phase）：事件对象以相反的顺序通过目标的祖先项传播，从目标的父项开始，到 Window 结束。该阶段也被称为 bubbling phase（反正翻译过来还是冒泡阶段）</li>
</ul>
<h3 id="默认动作和可取消事件"><a href="#默认动作和可取消事件" class="headerlink" title="默认动作和可取消事件"></a>默认动作和可取消事件</h3><p>事件通常由实现作为用户操作的结果进行分派，比如为了响应任务的完成，或者在异步活动期间发送进程信号（例如网络请求）。可以使用一些事件来控制实现接下来可能采取的行为(或撤消实现已经采取的动作)。这个类别中的事件称为可取消的（cancelable），它们取消的行为称为默认行为（default action）。可取消事件对象可以与一个或多个“默认动作”相关联。要取消事件，请调用 preventDefault() 方法。</p>
<blockquote>
<p>例子1：当用户按下指向设备(通常是鼠标)上的按钮后，立即会发出mousedown事件。实现可能采取的一个默认操作是设置一个状态机，允许用户拖动图像或选择文本。默认操作取决于接下来会发生什么——例如，如果用户的指向设备位于文本之上，可能会开始文本选择。如果用户的指向设备位于图像上方，则可以开始图像拖动操作。防止mousedown事件的默认操作将阻止这些操作的发生。</p>
</blockquote>
<p>默认操作通常在事件分派完成之后执行，但在特殊情况下，它们也可以在事件分派之前立即执行。</p>
<p>总结：感觉光看是不行的，还是要多实践，才能明白。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/23/promise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雯子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Athena">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/23/promise/" itemprop="url">
                  Promise
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-05-23 16:33:58" itemprop="dateCreated datePublished" datetime="2018-05-23T16:33:58+08:00">2018-05-23</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-01 13:39:36" itemprop="dateModified" datetime="2018-06-01T13:39:36+08:00">2018-06-01</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>原文：<a href="https://javascript.info/promise-basics" target="_blank" rel="noopener">Promise</a></p>
<p>想象一下，你是一个顶级歌手，你的粉丝们成天管要你的下一张专辑。<br>为了得到解脱，你向他们承诺，一旦专辑发行了就会立即寄给他们。你给粉丝们一张表让他们填写地址，这样一来一旦歌曲发行了，所有预定的人都能马上拿到。如果发生了什么意外，比如歌曲再也不会发行了，他们也会收到通知。</p>
<p>这样就皆大欢喜了，再也不会有人来烦你了，粉丝们也不会错过你的专辑单曲。</p>
<p>以上是一个真实世界的类比，我们在编程的过程中经常会遇到类似的情景：</p>
<ol>
<li>“生产代码”会做一些事情，会需要一些时间。例如，加载异步脚本。这就相当于那个“歌手”。</li>
<li>“消费代码”则是等准备好了之后获取结果。很多函数都可能需要这个结果。这就相当于那些“粉丝”。</li>
<li><em>promise</em> 就是一个特殊的JavaScript对象，它把它们连接起来。这就相当于那个“列表”。生产代码做出来之后发给每个人，这样他们就都能订阅这个结果了。</li>
</ol>
<p>虽然这个类比并不是非常的准确，因为JavaScript promise比一个简单的列表复杂得多，它们有额外的特性和限制，但是这个比喻还是可以帮助我们理解的。</p>
<p>一个promise对象的构建语法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 执行者 (生产代码, "歌手")</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>传给<code>new Promise</code>的函数叫做<em>执行者</em>。当promise被创建之后，<em>执行者</em>就被立即调用。它包括了生产代码，也就是最终要通过得到一个结果来结束。基于上面的类比，这个执行者就是一个“歌手”。</p>
<p>生成的<code>promise</code>对象有内部属性：</p>
<ul>
<li><code>state</code> – 初始值是“pending”，之后会变成“fulfilled”或者“rejected”</li>
<li><code>result</code> – 任意值，初始值是<code>undefined</code></li>
</ul>
<p>当执行者结束这个任务后，就会调用下面两个函数的一个：</p>
<ul>
<li><code>resolve(value)</code> – 表明任务成功结束:<ul>
<li>将 <code>state</code> 置成 <code>&quot;fulfilled&quot;</code>,</li>
<li>将 <code>result</code> 置成 <code>value</code>.</li>
</ul>
</li>
<li><code>reject(error)</code> – 表明发生了错误:<ul>
<li>将 <code>state</code> 置成 <code>&quot;rejected&quot;</code>,</li>
<li>将 <code>result</code> 置成 <code>error</code>.</li>
</ul>
</li>
</ul>
<img src="/2018/05/23/promise/promise-resolve-reject.png">
<p>下面是一个简单的执行者的例子，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当promise被构造的时候，这个函数就被立即执行</span></span><br><span class="line"></span><br><span class="line">  alert(resolve); <span class="comment">// function () &#123; [native code] &#125;</span></span><br><span class="line">  alert(reject);  <span class="comment">// function () &#123; [native code] &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1秒之后这个任务完成，输出结果"done!"</span></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"done!"</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>通过运行上面的代码，我们可以看出两件事情：</p>
<ol>
<li>这个执行者被立即自动调用了（通过 <code>new Promise</code>）</li>
<li>执行者接收两个参数：<code>resolve</code> 和 <code>reject</code> – 这些函数来自JavaScript引擎。我们不需要去创建它们。而且该由执行者来调用它们。</li>
</ol>
<p>1秒之后，执行者调用<code>resolve(&quot;done&quot;)</code>生成结果：</p>
<img src="/2018/05/23/promise/promise-resolve-1.png">
<p>这是任务成功完成的一个例子。</p>
<p>现在再看一个执行者抛出异常的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1秒之后任务结束，抛出异常</span></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Whoops!"</span>)), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>总结一下就是，执行者会执行一个任务（通常是需要花费一定时间的），然后调用 <code>resolve</code> 或者 <code>reject</code>来改变相应的promise对象的状态。</p>
<p>不管是<code>resolve</code> 还是 <code>reject</code>都会被叫做 “settled”，与 “pending”相对应。</p>
<h4 id="只能有一个结果或者异常"><a href="#只能有一个结果或者异常" class="headerlink" title="只能有一个结果或者异常"></a>只能有一个结果或者异常</h4><p>执行者只能调用一个<code>resolve</code> 或者 <code>reject</code>。promise的状态改变就是最终形态。<br>后面的任何调用都是无效的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">"done"</span>);</span><br><span class="line"></span><br><span class="line">  reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"…"</span>)); <span class="comment">// 无效</span></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"…"</span>)); <span class="comment">// 无效</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>至于一个任务执行完成只能有一个结果或者异常这个事情来说，在编程领域，还存在其它数据结构允许很多“流”结果，例如数据流（streams）和队列（queues）。相对于promise，它们也是各有利弊。Javascript核心不支持它们，而且缺少一些只有promise能提供的语言特性，这里我们不做过多的涉及。</p>
<p>还有就是如果我们调用<code>resolve/reject</code>时传入了多个参数，只有第一个参数有用，后面的都会被忽略的。</p>
<h4 id="Reject-使用-Error-对象"><a href="#Reject-使用-Error-对象" class="headerlink" title="Reject 使用 Error 对象"></a>Reject 使用 <code>Error</code> 对象</h4><p>通常来说我们可以像调用<code>resolve</code>一样传入任何参数来调用<code>reject</code>。但还是推荐使用<code>Error</code> 对象。原因的话后面会提。</p>
<h4 id="Resolve-reject-可以是立即执行的"><a href="#Resolve-reject-可以是立即执行的" class="headerlink" title="Resolve/reject 可以是立即执行的"></a>Resolve/reject 可以是立即执行的</h4><p>在练习中，执行者通常是做一些异步操作，在一段时间之后才调用<code>resolve/reject</code>，但其实并不一定是这样。我们可以立即调用<code>resolve</code> or <code>reject</code>函数，例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="number">123</span>); <span class="comment">// 立即给出结果：123</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>一般这种情况发生在，当我们开始要执行一个任务的时候，来看一下是不是多有的事情都准备好了。然后得到一个resolvedpromise表示可以做下面的事情了。</p>
<h3 id="state-和-result-是内部变量"><a href="#state-和-result-是内部变量" class="headerlink" title="state 和 result 是内部变量"></a><code>state</code> 和 <code>result</code> 是内部变量</h3><p><code>state</code> 和 <code>result</code>属性是一个promise对象的内部变量。我们不能在代码中直接访问它们，但是可以使用<code>.then/catch</code>方法，下面会说。</p>
<h2 id="消费者-“-then”-和-“-catch”"><a href="#消费者-“-then”-和-“-catch”" class="headerlink" title="消费者: “.then” 和 “.catch”"></a>消费者: “.then” 和 “.catch”</h2><p>promise对象作为生产代码（执行者）和消费函数（那些想要接收结果或者错误的函数）之间的连接桥梁，消费函数可以使用方法<code>promise.then</code> and <code>promise.catch</code>来注册。</p>
<p><code>.then</code>的语法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123; <span class="comment">/* 处理成功的 result */</span> &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123; <span class="comment">/* 处理 error */</span> &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>如果promise执行成功，得到result，就会执行第一个参数函数，如果promise返回错误就会执行第二个参数函数</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"done!"</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// resolve runs the first function in .then</span></span><br><span class="line">promise.then(</span><br><span class="line">  result =&gt; alert(result), <span class="comment">// 1秒之后显示 "done!"</span></span><br><span class="line">  error =&gt; alert(error) <span class="comment">// 不会执行</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>reject的例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Whoops!"</span>)), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// reject runs the second function in .then</span></span><br><span class="line">promise.then(</span><br><span class="line">  result =&gt; alert(result), <span class="comment">// 不会执行</span></span><br><span class="line">  error =&gt; alert(error) <span class="comment">// 1秒之后显示 "done!" "Error: Whoops!"</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>如果我们只需要成功的情况，那么也可以只提供一个参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"done!"</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(alert); <span class="comment">// 1秒之后显示 "done!"</span></span><br></pre></td></tr></table></figure>
<p>如果只对errors感兴趣，那么可以使用<code>.then(null, function)</code>或者<code>.catch(function)</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Whoops!"</span>)), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// .catch(f) 与 promise.then(null, f)是一样的</span></span><br><span class="line">promise.catch(alert); <span class="comment">// 1秒之后显示 "done!" "Error: Whoops!"</span></span><br></pre></td></tr></table></figure>
<p><code>.catch(f)</code> 与 <code>.then(null, f)</code>是完全等同的。</p>
<h3 id="settled的-promise会立即执行-then"><a href="#settled的-promise会立即执行-then" class="headerlink" title="settled的 promise会立即执行 then"></a>settled的 promise会立即执行 <code>then</code></h3><p>如果一个promise在pending，<code>.then/catch</code>处理器会等待result。另外，如果一个promise状态已经是settled， 它们会立即执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个立即 resolved 的 promise</span></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="string">"done!"</span>));</span><br><span class="line"></span><br><span class="line">promise.then(alert); <span class="comment">// done! (立即显示出来)</span></span><br></pre></td></tr></table></figure>
<p>对于那些有时需要时间，有时立即完成的任务，这样处理是非常方便的，并且能够保证两种情况都能正常运行。</p>
<h3 id="then-catch的处理器永远是异步的"><a href="#then-catch的处理器永远是异步的" class="headerlink" title=".then/catch的处理器永远是异步的"></a><code>.then/catch</code>的处理器永远是异步的</h3><p>更严格来说，当<code>.then/catch</code>处理器要执行的时候，首先会加入一个内部序列。当当前的代码执行完毕之后，JavaScript引擎从序列中取出这些处理器并执行，和<code>setTimeout(..., 0)</code>类似。</p>
<p>换句话说，当<code>.then(handler)</code>将要触发的时候，它的行为类似于<code>setTimeout(handler, 0)</code></p>
<p>在下面的例子中，promise立即resolved，所以<code>.then(alert)</code>也会马上触发：<code>alert</code>回调加入序列，然后等到代码执行结束后，立即执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个立即resolved的promise</span></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="string">"done!"</span>));</span><br><span class="line"></span><br><span class="line">promise.then(alert); <span class="comment">// done! (在当前代码运行结束之后)</span></span><br><span class="line"></span><br><span class="line">alert(<span class="string">"code finished"</span>); <span class="comment">// 这个alert会先显示出来</span></span><br></pre></td></tr></table></figure>
<p>所以在<code>.then</code>后面的代码通常是先于then执行的，即使是在立即resolve的promise情况下。通常这不是很重要，只有一些情况可能会有用。</p>
<p>下面我们来看一些更多的例子，promise如何帮助我们编写异步代码</p>
<h2 id="例子-loadScript"><a href="#例子-loadScript" class="headerlink" title="例子: loadScript"></a>例子: loadScript</h2><p>比如下面的<code>loadScript</code>函数，用的是callback回调函数的写法，用来加载一个脚本：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">src, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">  script.src = src;</span><br><span class="line"></span><br><span class="line">  script.onload = <span class="function"><span class="params">()</span> =&gt;</span> callback(<span class="literal">null</span>, script);</span><br><span class="line">  script.onerror = <span class="function"><span class="params">()</span> =&gt;</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Script load error `</span> + src));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">document</span>.head.append(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们用promise重写一下</p>
<p><code>loadScript</code>新方法不需要回调函数作为参数了。当加载文件完成后，会创建并返回一个promise对象。外面的代码可以用<code>.then</code>来添加后续处理的方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.src = src;</span><br><span class="line"></span><br><span class="line">    script.onload = <span class="function"><span class="params">()</span> =&gt;</span> resolve(script);</span><br><span class="line">    script.onerror = <span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Script load error: "</span> + src));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.head.append(script);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = loadScript(<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js"</span>);</span><br><span class="line"></span><br><span class="line">promise.then(</span><br><span class="line">  script =&gt; alert(<span class="string">`<span class="subst">$&#123;script.src&#125;</span> is loaded!`</span>),</span><br><span class="line">  error =&gt; alert(<span class="string">`Error: <span class="subst">$&#123;error.message&#125;</span>`</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">script</span> =&gt;</span> alert(<span class="string">'One more handler to do something else!'</span>));</span><br></pre></td></tr></table></figure>
<p>通过与这种基于回调函数语法的对比，我们可以立即找出一些优点：</p>
<p>callback：</p>
<ul>
<li>我们必须提前准备好<code>callback</code>函数，也就是说我们必须在<code>loadScript</code>调用之前就要处理结果。</li>
<li>只能有一个callback。</li>
</ul>
<p>Promise：</p>
<ul>
<li>Promise可以让我们用一种非常自然的顺序来编写代码。首先我们运行<code>loadScript</code>， 然后再继续写处理结果的逻辑。</li>
<li>我们可以事后多次调用<code>.then</code></li>
</ul>
<p>所以promise给我们带来了更好的代码流和灵活性。但是不只是这些，我们下章再继续。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/11/Element-ui升级2.0后初体验/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雯子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Athena">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/11/Element-ui升级2.0后初体验/" itemprop="url">
                  未命名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-12-11 10:55:52 / 修改时间：16:46:27" itemprop="dateCreated datePublished" datetime="2017-12-11T10:55:52+08:00">2017-12-11</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Element-ui升级2.0后初体验</p>
<p>如果你在使用Vue和Element-ui进行前端开发，那么就会知道Element在2017年10月27日升级到了2.0.0 Carbon的版本，改动可以说还是有些大的。可想而知，有的人选择按兵不动，有的人选择先睹为快。</p>
<p>现在打开Element-ui的官网，切换到1.4.12的文档，可以看到一个提示消息框：</p>
<blockquote>
<p>Element 1.x 已停止维护，请升级至 2.x</p>
</blockquote>
<p>所以还是建议尽早升级比较好，顺便也可以一起升级一下vue到2.5版本以上。下面我会介绍一些我在升级项目的过程中遇到的问题和需要注意的地方。</p>
<p>升级后的版本：<br>element-ui：2.0.4（最新版本已经到2.0.7）<br>vue：2.5.4</p>
<p>首先说一下整体印象，由于我做的这个项目是管理控制台类型的，升级后第一印象是页面变“白”了，也可以说变淡了，尤其是侧边栏、导航菜单，以前是可以选择深色的主题，现在没有这个<code>theme-default</code>预设了，新增了新的主题<code>chalk</code>，导致整个页面都是白白的。个人理解以后官方可能会出别的系列的主题，这样方便拆解和设计。<br>表格的表头原来也是有背景颜色区分的，现在的chalk主题下表头的颜色区分不是很明显。然后之前用的tag、按钮之类的都变大了，这是在什么都没设置，直接升级以后的第一眼效果。</p>
<p>然后下面说一下我遇到的需要修改的地方。</p>
<h4 id="1-引入的css文件路径变了"><a href="#1-引入的css文件路径变了" class="headerlink" title="1. 引入的css文件路径变了"></a>1. 引入的css文件路径变了</h4><p>原来是：<br><code>import &#39;element-ui/lib/theme-default/index.css&#39;</code><br>现在需要修改成：<br><code>import &#39;element-ui/lib/theme-chalk/index.css&#39;</code></p>
<h4 id="2-样式引入的优先级问题"><a href="#2-样式引入的优先级问题" class="headerlink" title="2. 样式引入的优先级问题"></a>2. 样式引入的优先级问题</h4><p>之前遇到这样一个问题，有的组件样式需要进行定制覆盖，于是就在组件里面用css scoped进行了同类名的样式替换，这样在开发环境下效果是符合预期的，但是打包编译后，优先级就变了。于是发现是在<code>main.js</code>引入文件路径顺序的问题，之前一度以为不需要顺序，但其实还是有影响的。</p>
<p>原来的配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> ElementUI <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'element-ui/lib/theme-chalk/index.css'</span></span><br><span class="line"></span><br><span class="line">Vue.use(ElementUI)</span><br></pre></td></tr></table></figure>
<p>修改后的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> ElementUI <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'element-ui/lib/theme-chalk/index.css'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span> <span class="comment">//这里要把App的引用顺序放到最后</span></span><br><span class="line"></span><br><span class="line">Vue.use(ElementUI)</span><br></pre></td></tr></table></figure>
<h4 id="3-Icon的变化"><a href="#3-Icon的变化" class="headerlink" title="3. Icon的变化"></a>3. Icon的变化</h4><p>原来在<code>input</code>组件中可以用<code>icon</code>这个属性指定icon，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-input</span><br><span class="line">  icon=&quot;search&quot;&gt;</span><br><span class="line">&lt;/el-input&gt;</span><br></pre></td></tr></table></figure>
<p>现在的话，这样写是不生效的：</p>
<blockquote>
<p>可以通过<code>prefix-icon</code> 和 <code>suffix-icon</code> 属性在 input 组件首部和尾部增加显示图标，也可以通过 slot 来放置图标。</p>
</blockquote>
<p>所以如果你在项目中的<code>input</code>里用到了<code>icon</code>的属性，需要改成<code>prefix-icon</code> 或 <code>suffix-icon</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-input</span><br><span class="line">	suffix-icon=&quot;el-icon-search&quot;&gt;</span><br><span class="line">&lt;/el-input&gt;</span><br></pre></td></tr></table></figure>
<p>但是button组件就还是可以使用<code>icon</code>属性，但需要传入完整的图标类名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-search&quot;&gt;搜索&lt;/el-button&gt;</span><br></pre></td></tr></table></figure></p>
<p>原因是：</p>
<blockquote>
<p>为了方便使用第三方图标，Button 的 <code>icon</code> 属性、Input 的 <code>prefix-icon</code> 和 <code>suffix-icon</code> 属性、Steps 的 <code>icon</code> 属性现在需要传入完整的图标类名</p>
</blockquote>
<h4 id="4-modal的变化"><a href="#4-modal的变化" class="headerlink" title="4. modal的变化"></a>4. modal的变化</h4><p>之前给不需要宽度的modal设了<code>width: auto;</code>，这样如果里面内容为空的时候基本没有宽度，更新后，如果没有内容，默认会铺满整个屏幕。</p>
<h4 id="5-NavMenu-导航菜单"><a href="#5-NavMenu-导航菜单" class="headerlink" title="5. NavMenu 导航菜单"></a>5. NavMenu 导航菜单</h4><p>原来的menu是有两个样式供选择的，<code>theme</code>有两个可选值<code>light, dark</code>，现在没有这个属性了，默认就是chalk主题的白色，如果想要定制，需要另外设置。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
<th>类型</th>
<th>可选值</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>background-color</td>
<td>菜单的背景色（仅支持 hex 格式）</td>
<td>string</td>
<td>—</td>
<td>#ffffff</td>
</tr>
<tr>
<td>text-color</td>
<td>菜单的文字颜色（仅支持 hex 格式）</td>
<td>string</td>
<td>—</td>
<td>#409EFF</td>
</tr>
<tr>
<td>active-text-color</td>
<td>当前激活菜单的文字颜色（仅支持 hex 格式）</td>
<td>string</td>
<td>—</td>
<td>#409EFF</td>
</tr>
</tbody>
</table>
<p>但是这样设置会有弊端，如果项目经过定制样式改过主题颜色，那么这里就需要进行单独设置，而且还仅支持 hex 格式，这就需要计算出来颜色的具体值，而不能通过scss变量来控制。</p>
<h4 id="6-slot-scope"><a href="#6-slot-scope" class="headerlink" title="6. slot-scope"></a>6. slot-scope</h4><p>这其实是[vue在2.5.0里的变化][1]<br>把<code>scope</code>换成了<code>slop-scope</code><br>所以在element里面升级后，也把相应的用到scope的地方做修改就行了</p>
<h4 id="7-checkbox"><a href="#7-checkbox" class="headerlink" title="7. checkbox"></a>7. checkbox</h4><p>在更新后测试的时候发现checkbox挂了，于是查看，发现Checkbox Events的<code>change</code>事件的参数变了：</p>
<p>1.0:</p>
<p><img src="https://segmentfault.com/img/bVY0CM?w=854&amp;h=167" alt="clipboard.png"></p>
<p>2.0:</p>
<p><img src="https://segmentfault.com/img/bVY0CQ?w=905&amp;h=185" alt="clipboard.png"></p>
<p>所以，原来1.0判断change函数里面是这么写的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">handleCheckAllChange(event) &#123;</span><br><span class="line">    this.checkedCities = event.target.checked ? cityOptions : [];</span><br><span class="line">    this.isIndeterminate = false;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>2.0是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">handleCheckAllChange(val) &#123;</span><br><span class="line">    this.checkedCities = val ? cityOptions : [];</span><br><span class="line">    this.isIndeterminate = false;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>目前就是这么多，随着项目深入，可能还会遇到更多的问题和兼容版本的问题，我们可以共同探讨。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/15/怎样在vue项目下添加Eslint/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雯子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Athena">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/15/怎样在vue项目下添加Eslint/" itemprop="url">
                  怎样在vue项目下添加Eslint
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-11-15 15:13:40 / 修改时间：15:48:44" itemprop="dateCreated datePublished" datetime="2017-11-15T15:13:40+08:00">2017-11-15</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简易搭建"><a href="#简易搭建" class="headerlink" title="简易搭建"></a>简易搭建</h2><p><a href="https://eslint.org/" target="_blank" rel="noopener">ESLint官网网址</a></p>
<p><a href="http://eslint.cn/" target="_blank" rel="noopener">ESLint中文官网</a></p>
<p>如果你是想在自己的项目里搭建ESLint，就可以按照官网的指示，</p>
<p>以全局安装举例，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g eslint</span><br></pre></td></tr></table></figure>
<p>然后初始化</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eslint --init</span><br></pre></td></tr></table></figure>
<p>它会问你一些问题，你可以按照你的喜好进行配置，我选的是popular下面的standard，生成的文件是js格式，那么就会创建出<code>eslintrc.js</code>文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"><span class="string">"extends"</span>: <span class="string">"standard"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后就可以简单的lint某个文件了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ eslint yourfile.js</span><br></pre></td></tr></table></figure>
<h2 id="在vue的项目里新添加ESLint"><a href="#在vue的项目里新添加ESLint" class="headerlink" title="在vue的项目里新添加ESLint"></a>在vue的项目里新添加ESLint</h2><p>有的时候，早期的时候，我们建立vue项目的时候，可能图简便，并没有初始化ESLint、单元测试等等模块，那么就需要后添加进去。</p>
<p>如果是现在新建一个项目，通过vue-cli的问答就可以轻松初始化ESLint的配置。</p>
<p>这里说一下怎样在老项目里新添加ESLint。</p>
<p>首先，我先用vue-cli创建了一个新项目，在初始化的时候，选择安装eslint，</p>
<p>选择standard规则，然后就生成了<code>eslintrc.js</code>，把生成的这个文件拷贝到要加ESlint的老项目里。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://eslint.org/docs/user-guide/configuring</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//默认情况下，ESLint 会在所有父级目录里寻找配置文件，一直到根目录。如果你想要你所有项目都遵循一个特定的约定时，这将会很有用，但有时候会导致意想不到的结果。为了将 ESLint 限制到一个特定的项目，在你项目根目录下的 package.json 文件或者 .eslintrc.* 文件里的 eslintConfig 字段下设置 "root": true。ESLint 一旦发现配置文件中有 "root": true，它就会停止在父级目录中寻找。</span></span><br><span class="line">  root: <span class="literal">true</span>,</span><br><span class="line">  parser: <span class="string">'babel-eslint'</span>,</span><br><span class="line">  parserOptions: &#123;</span><br><span class="line">    sourceType: <span class="string">'module'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  env: &#123;</span><br><span class="line">    browser: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// https://github.com/standard/standard/blob/master/docs/RULES-en.md</span></span><br><span class="line">  extends: <span class="string">'standard'</span>,</span><br><span class="line">  <span class="comment">// required to lint *.vue files</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="string">'html'</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// add your custom rules here</span></span><br><span class="line">  <span class="string">'rules'</span>: &#123;</span><br><span class="line">    <span class="comment">// allow paren-less arrow functions 要求箭头函数的参数使用圆括号</span></span><br><span class="line">    <span class="string">'arrow-parens'</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="comment">// allow async-await 强制 generator 函数中 * 号周围使用一致的空格</span></span><br><span class="line">    <span class="string">'generator-star-spacing'</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="comment">// allow debugger during development</span></span><br><span class="line">    <span class="string">'no-debugger'</span>: process.env.NODE_ENV === <span class="string">'production'</span> ? <span class="number">2</span> : <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后找到<code>package.json</code>，把ESLint相关的依赖加进去（也可以一个一个进行安装，或者有更好的办法。。）</p>
<p><img src="file:///var/folders/tw/l4f5twr93wl5fcvpnrwd8nvr0000gp/T/WizNote/6ef8389b-88cf-4ee1-aa09-772bb5afb6f1/index_files/68513208.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;babel-eslint&quot;: &quot;^7.1.1&quot;,   &quot;eslint&quot;: &quot;^3.19.0&quot;,</span><br><span class="line"></span><br><span class="line">&quot;eslint-friendly-formatter&quot;: &quot;^3.0.0&quot;,</span><br><span class="line">&quot;eslint-loader&quot;: &quot;^1.7.1&quot;,</span><br><span class="line">&quot;eslint-plugin-html&quot;: &quot;^3.0.0&quot;,</span><br><span class="line">&quot;eslint-config-standard&quot;: &quot;^10.2.1&quot;,</span><br><span class="line">&quot;eslint-plugin-promise&quot;: &quot;^3.4.0&quot;,</span><br><span class="line">&quot;eslint-plugin-standard&quot;: &quot;^3.0.1&quot;,</span><br><span class="line">&quot;eslint-plugin-import&quot;: &quot;^2.7.0&quot;,</span><br><span class="line">&quot;eslint-plugin-node&quot;: &quot;^5.2.0&quot;,</span><br></pre></td></tr></table></figure>
<p>然后在<code>webpack.base.conf.js</code>的rules里添加</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">       test: <span class="regexp">/\.(js|vue)$/</span>,</span><br><span class="line">       loader: <span class="string">'eslint-loader'</span>,</span><br><span class="line">       enforce: <span class="string">'pre'</span>,</span><br><span class="line">       include: [resolve(<span class="string">'src'</span>), resolve(<span class="string">'test'</span>)],</span><br><span class="line">       options: &#123;</span><br><span class="line">         formatter: <span class="built_in">require</span>(<span class="string">'eslint-friendly-formatter'</span>)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;,</span><br></pre></td></tr></table></figure>
<p>再<code>npm install</code>一下，应该就可以了。</p>
<p>这里的编辑器推荐用vscode，可以非常智能的显示出哪里出错，方便修改。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/26/雯子前端半月刊-201710下/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雯子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Athena">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/26/雯子前端半月刊-201710下/" itemprop="url">
                  雯子前端半月刊-201710下
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-10-26 21:49:13" itemprop="dateCreated datePublished" datetime="2017-10-26T21:49:13+08:00">2017-10-26</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-11-15 10:35:51" itemprop="dateModified" datetime="2017-11-15T10:35:51+08:00">2017-11-15</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>10月下旬有那么一周的某几天相对闲一些，看了一点东西，记录一下，本来以为有挺多，其实就这么点。。</p>
<ol>
<li><p><a href="https://github.com/twbs/bootstrap/releases/tag/v4.0.0-beta.2" target="_blank" rel="noopener">Bootstrap v4.0.0-beta.2</a> 发布了，虽然说基本上绝大多数前端都用过Bootstrap，但是又有多少是真正用透了的呢。对于我来说最想引入的是flex布局和Sass的定制样式。可以统一一波现在项目中的老旧样式。</p>
</li>
<li><p><a href="https://github.com/hakimel/reveal.js" target="_blank" rel="noopener">reveal.js</a>接触了一下，还没用，觉得用代码写，要都写在index.html中，要以html中内嵌markdown的格式，感觉有些怪怪的，不知道有没有大神好好地用过的。</p>
</li>
<li><p>学习了一遍Vue官方文档的<a href="https://cn.vuejs.org/v2/style-guide/" target="_blank" rel="noopener">风格指南</a>，有一些地方还是蛮有用的，比如以前对于props的定义都是行内的，其实都应该写成详细模式。</p>
<blockquote>
<p>细致的 prop 定义有两个好处：<br>•    它们写明了组件的 API，所以很容易看懂组件的用法；<br>•    在开发环境下，如果向一个组件提供格式不正确的 prop，Vue 将会告警，以帮助你捕获潜在的错误来源。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更好的做法！</span></span><br><span class="line">props: &#123;</span><br><span class="line">  status: &#123;</span><br><span class="line">    type: <span class="built_in">String</span>,</span><br><span class="line">    required: <span class="literal">true</span>,</span><br><span class="line">    validator: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> [</span><br><span class="line">        <span class="string">'syncing'</span>,</span><br><span class="line">        <span class="string">'synced'</span>,</span><br><span class="line">        <span class="string">'version-conflict'</span>,</span><br><span class="line">        <span class="string">'error'</span></span><br><span class="line">      ].indexOf(value) !== <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而且这个文档中还有好多困扰我好久的命名规则的问题，如果你有同样的困扰，可以趁代码和组件没有太多的时候，优化一下整个项目，并记住且让整个团队也养成这些命名习惯。</p>
</li>
<li><p>css modules了解</p>
<p>阮一峰的教程：<a href="http://www.ruanyifeng.com/blog/2016/06/css_modules.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/06/css_modules.html</a></p>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/01/vue源码项目/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雯子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Athena">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/01/vue源码项目/" itemprop="url">
                  vue源码项目
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-06-01 19:34:23" itemprop="dateCreated datePublished" datetime="2017-06-01T19:34:23+08:00">2017-06-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-06-02 15:13:34" itemprop="dateModified" datetime="2017-06-02T15:13:34+08:00">2017-06-02</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><ul>
<li><strong><code>build</code></strong>: 包含构建相关的内置文件。在大多数情况下你不需要去动它们。然而，熟悉一下下面的文件可能会有帮助。</li>
<li><p><code>build/alias.js</code>: 所有的源码和测试用到的模块引入别名</p>
</li>
<li><p><code>build/config.js</code>: 包含<code>dist/</code>文件夹下面生成的所有文件文件的build配置。这个文件是dist文件夹的源文件生成入口。</p>
</li>
<li><p><strong><code>dist</code></strong>: 包含分发的构建文件。注意这个目录只会在一个release发布的时候才会更新；在development分支的最新变化不会实时反映出来。</p>
</li>
</ul>
<p>See <a href="https://github.com/vuejs/vue/blob/dev/dist/README.md" target="_blank" rel="noopener">dist/README.md</a> for more details on dist files.</p>
<ul>
<li><p><strong><code>flow</code></strong>: 包含类型声明，用的是 <a href="https://flowtype.org/" target="_blank" rel="noopener">Flow</a>. 这些声明都是<strong>全局</strong>加载的，所以你会看到它们在源码中类型注释的使用。</p>
</li>
<li><p><strong><code>packages</code></strong>: 包含 <code>vue-server-renderer</code> 和 <code>vue-template-compiler</code>,是分离的NPM包。它们都是从源码里自动生成的，并且与main <code>vue</code> package有着同样的版本。</p>
</li>
<li><p><strong><code>test</code></strong>: 包含所有的测试. The unit tests are written with <a href="http://jasmine.github.io/2.3/introduction.html" target="_blank" rel="noopener">Jasmine</a> and run with <a href="http://karma-runner.github.io/0.13/index.html" target="_blank" rel="noopener">Karma</a>. The e2e tests are written for and run with <a href="http://nightwatchjs.org/" target="_blank" rel="noopener">Nightwatch.js</a>.</p>
</li>
<li><p><strong><code>src</code></strong>: contains the source code, obviously. The codebase is written in ES2015 with <a href="https://flowtype.org/" target="_blank" rel="noopener">Flow</a> type annotations.</p>
<ul>
<li><p><strong><code>compiler</code></strong>: contains code for the template-to-render-function compiler.</p>
<p>The compiler consists of a parser (converts template strings to element ASTs), an optimizer (detects static trees for vdom render optimization), and a code generator (generate render function code from element ASTs). Note the codegen directly generates code strings from the element AST - it’s done this way for smaller code size because the compiler is shipped to the browser in the standalone build.</p>
</li>
<li><p><strong><code>core</code></strong>: contains universal, platform-agnostic runtime code.</p>
<p>The Vue 2.0 core is platform-agnostic - which means code inside <code>core</code> should be able to run in any JavaScript environment, be it the browser, Node.js, or an embedded JavaScript runtime in native applications.</p>
<ul>
<li><p><strong><code>observer</code></strong>: contains code related to the reactivity system.</p>
</li>
<li><p><strong><code>vdom</code></strong>: contains code related to vdom element creation and patching.</p>
</li>
<li><p><strong><code>instance</code></strong>: contains Vue instance constructor and prototype methods.</p>
</li>
<li><p><strong><code>global-api</code></strong>: as the name suggests.</p>
</li>
<li><p><strong><code>components</code></strong>: universal abstract components. Currently <code>keep-alive</code> is the only one.</p>
</li>
</ul>
</li>
<li><p><strong><code>server</code></strong>: contains code related to server-side rendering.</p>
</li>
<li><p><strong><code>platforms</code></strong>: contains platform-specific code.</p>
<p>Entry files for dist builds are located in their respective platform directory.</p>
<p>Each platform module contains three parts: <code>compiler</code>, <code>runtime</code> and <code>server</code>, corresponding to the three directories above. Each part contains platform-specific modules/utilities which are then imported and injected to the core counterparts in platform-specific entry files. For example, the code implementing the logic behind <code>v-bind:class</code> is in <code>platforms/web/runtime/modules/class.js</code> - which is imported in <code>entries/web-runtime.js</code> and used to create the browser-specific vdom patching function.</p>
</li>
<li><p><strong><code>sfc</code></strong>: contains single-file component (<code>*.vue</code> files) parsing logic. This is used in the <code>vue-template-compiler</code> package.</p>
</li>
<li><p><strong><code>shared</code></strong>: contains utilities shared across the entire codebase.</p>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/24/javascript高级程序设计笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雯子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Athena">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/24/javascript高级程序设计笔记/" itemprop="url">
                  javascript高级程序设计笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-04-24 18:52:56" itemprop="dateCreated datePublished" datetime="2017-04-24T18:52:56+08:00">2017-04-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-10-31 23:04:06" itemprop="dateModified" datetime="2018-10-31T23:04:06+08:00">2018-10-31</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第四章-变量、作用域和内存问题"><a href="#第四章-变量、作用域和内存问题" class="headerlink" title="第四章 变量、作用域和内存问题"></a>第四章 变量、作用域和内存问题</h2><h3 id="4-1-基本类型和引用类型"><a href="#4-1-基本类型和引用类型" class="headerlink" title="4.1 基本类型和引用类型"></a>4.1 基本类型和引用类型</h3><p>基本类型：Undefined, Null, Boolean, Number, String，按值访问，可以操作保存在变量中的实际值。</p>
<p>引用类型： 保存在内存中的对象，按引用访问。</p>
<p>如果从一个变量向另一个变量复制<strong>基本类型</strong>的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> num2 = num;</span><br></pre></td></tr></table></figure>
<p><img src="/images/4.1 复制基本类型值的过程.png" alt="4.1 复制基本类型值的过程"></p>
<p>当一个变量向另一个变量复制<strong>引用类型</strong>的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值得副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。</p>
<p><em>用我的话理解就是，引用类型的变量本体会存在堆中，而复制的是指向堆内存的指针，两个指针都指向一个堆内存，也就是引用了同一个对象。</em></p>
<p>指针指向对象，变量引用同一个对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br><span class="line">obj1.name = <span class="string">"Athena"</span>;</span><br><span class="line">alert(obj2.name); <span class="comment">//"Athena"</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/4.2 保存在变量对象中的变量和保存在堆中的对象之间的关系.png" alt="4.2 保存在变量对象中的变量和保存在堆中的对象之间的关系"></p>
<p>ECMAScript中所有的参数都是按值传递的。举几个例子就一目了然了。</p>
<p>参数为对象的情况</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  obj.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line">alert(person.name); <span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  obj.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">  obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  obj.name = <span class="string">"Greg"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line">alert(person.name); <span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure>
<h4 id="4-1-4-检测类型"><a href="#4-1-4-检测类型" class="headerlink" title="4.1.4 检测类型"></a>4.1.4 检测类型</h4><p>检测基本数据类型用typeof</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"Nicholas"</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">var</span> u;</span><br><span class="line"><span class="keyword">var</span> n = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line"></span><br><span class="line">alert(<span class="keyword">typeof</span> s); <span class="comment">//string</span></span><br><span class="line">alert(<span class="keyword">typeof</span> b); <span class="comment">//boolean</span></span><br><span class="line">alert(<span class="keyword">typeof</span> i); <span class="comment">//number</span></span><br><span class="line">alert(<span class="keyword">typeof</span> u); <span class="comment">//undefined</span></span><br><span class="line">alert(<span class="keyword">typeof</span> n); <span class="comment">//Object</span></span><br><span class="line">alert(<span class="keyword">typeof</span> o); <span class="comment">//Object</span></span><br></pre></td></tr></table></figure>
<p>instanceof用来检测是什么类型的对象</p>
<p><code>result = variable instanceof constructor</code></p>
<h3 id="4-3-垃圾收集"><a href="#4-3-垃圾收集" class="headerlink" title="4.3 垃圾收集"></a>4.3 垃圾收集</h3><h4 id="4-3-1-标记清除（主流）"><a href="#4-3-1-标记清除（主流）" class="headerlink" title="4.3.1 标记清除（主流）"></a>4.3.1 标记清除（主流）</h4><p>javascript中最常用的垃圾收集方式。当变量进入环境时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”</p>
<p>思想是给当前不使用的值加上标记，然后再回收其内存</p>
<h4 id="4-3-2-引用计数（罕见-IE）"><a href="#4-3-2-引用计数（罕见-IE）" class="headerlink" title="4.3.2 引用计数（罕见 IE）"></a>4.3.2 引用计数（罕见 IE）</h4><h2 id="第五章-引用类型"><a href="#第五章-引用类型" class="headerlink" title="第五章 引用类型"></a>第五章 引用类型</h2><h3 id="5-1-Object类型"><a href="#5-1-Object类型" class="headerlink" title="5.1 Object类型"></a>5.1 Object类型</h3><p>创建有两种方式：</p>
<p>1) 使用new操作符后跟Object构造函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">"athena"</span>;</span><br><span class="line">person.age = <span class="number">26</span>;</span><br></pre></td></tr></table></figure>
<p>2) 使用对象字面量表示法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">"athena"</span>,</span><br><span class="line">  age: <span class="number">26</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line">person.name = <span class="string">"athena"</span>;</span><br><span class="line">person.age = <span class="number">26</span>;</span><br></pre></td></tr></table></figure></p>
<p>然后再说花括号的问题。在js中，有表达式上下文（expression context）和语句上下文（statement context）。表达式上下文指的是能够返回一个值（表达式），语句上下文例如跟在if语句条件后面，表达一个语句块的开始。在这里花括号处于表达式上下文中，则表示对象字面量的开始。</p>
<p>在封装函数时，对象字面量可以用来传递大量可选参数，而对那些必需值使用命名参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayInfo</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> args.age == <span class="string">"number"</span>) &#123;</span><br><span class="line">    output = args.age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">displayInfo(&#123;</span><br><span class="line">  age: <span class="number">29</span> <span class="comment">//这个参数可选</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="5-2-Array类型"><a href="#5-2-Array类型" class="headerlink" title="5.2 Array类型"></a>5.2 Array类型</h3><p>两种创建方式</p>
<p>1) 使用Array构造函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> colors = <span class="built_in">Array</span>(<span class="number">30</span>) <span class="comment">//这个方法不能用forEach 可以用原生的for循环</span></span><br><span class="line"><span class="keyword">var</span> colors = <span class="built_in">Array</span>(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>)</span><br></pre></td></tr></table></figure></p>
<p>2) 使用数组字面量表示法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [];</span><br><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]</span><br></pre></td></tr></table></figure>
<h4 id="5-2-1-检测数组"><a href="#5-2-1-检测数组" class="headerlink" title="5.2.1 检测数组"></a>5.2.1 检测数组</h4><p>对于一个网页，或者一个全局作用域而言，只有一个全局执行环境，使用<code>instanceof</code>操作符就可以：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">  <span class="comment">//对数组执行某些操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的狗在函数。</p>
<p>所以ECMAScript5新增了<code>Array.isArray()</code>方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">  <span class="comment">//对数组执行某些操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-5-Function类型"><a href="#5-5-Function类型" class="headerlink" title="5.5 Function类型"></a>5.5 Function类型</h3><p><em>函数是对象，函数名是指针</em></p>
<p>使用不带圆括号的函数名是访问函数指针，而非调用函数</p>
<h4 id="函数声明提升"><a href="#函数声明提升" class="headerlink" title="函数声明提升"></a>函数声明提升</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(sum(<span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/14/面试题整理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雯子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Athena">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/14/面试题整理/" itemprop="url">
                  面试题整理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-04-14 20:31:23" itemprop="dateCreated datePublished" datetime="2017-04-14T20:31:23+08:00">2017-04-14</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-04-17 22:10:26" itemprop="dateModified" datetime="2017-04-17T22:10:26+08:00">2017-04-17</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-new操作符具体做了什么"><a href="#1-new操作符具体做了什么" class="headerlink" title="1. new操作符具体做了什么"></a>1. new操作符具体做了什么</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> func = <span class="keyword">new</span> Func();</span><br></pre></td></tr></table></figure>
<p>new共经过了四个阶段</p>
<h4 id="1-创建一个空对象"><a href="#1-创建一个空对象" class="headerlink" title="1. 创建一个空对象"></a>1. 创建一个空对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure>
<h4 id="2-设置原型链"><a href="#2-设置原型链" class="headerlink" title="2. 设置原型链"></a>2. 设置原型链</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.__proto__= Func.prototype;</span><br></pre></td></tr></table></figure>
<h4 id="3-让Func中的this指向obj，并执行Func的函数体。"><a href="#3-让Func中的this指向obj，并执行Func的函数体。" class="headerlink" title="3. 让Func中的this指向obj，并执行Func的函数体。"></a>3. 让Func中的this指向obj，并执行Func的函数体。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = Func.call(obj);</span><br></pre></td></tr></table></figure>
<h4 id="4-判断Func的返回值类型："><a href="#4-判断Func的返回值类型：" class="headerlink" title="4. 判断Func的返回值类型："></a>4. 判断Func的返回值类型：</h4><p>如果是值类型，返回obj。如果是引用类型，就返回这个引用类型的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span>(result) == <span class="string">"object"</span>) &#123;</span><br><span class="line">  func = result;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  func = obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后再贴出来<a href="http://www.jianshu.com/p/15ac7393bc1f" target="_blank" rel="noopener">波同学</a>的写法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先一本正经的创建一个构造函数，其实该函数与普通函数并无区别</span></span><br><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将构造函数以参数形式传入</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">New</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个中间对象，该对象为最终返回的实例</span></span><br><span class="line">    <span class="keyword">var</span> res = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (func.prototype !== <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将实例的原型指向构造函数的原型</span></span><br><span class="line">        res.__proto__ = func.prototype;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ret为构造函数执行的结果，这里通过apply，将构造函数内部的this指向修改为指向res，即为实例对象</span></span><br><span class="line">    <span class="keyword">var</span> ret = func.apply(res, <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当我们在构造函数中明确指定了返回对象时，那么new的执行结果就是该返回对象</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">typeof</span> ret === <span class="string">"object"</span> || <span class="keyword">typeof</span> ret === <span class="string">"function"</span>) &amp;&amp; ret !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有明确指定返回对象，则默认返回res，这个res就是实例对象</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过new声明创建实例，这里的p1，实际接收的正是new中返回的res</span></span><br><span class="line"><span class="keyword">var</span> p1 = New(Person, <span class="string">'tom'</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1.getName());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然，这里也可以判断出实例的类型了</span></span><br><span class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<h2 id="2-JQuery-中-fn-extend-函数的实现（实现核心代码即可）"><a href="#2-JQuery-中-fn-extend-函数的实现（实现核心代码即可）" class="headerlink" title="2. JQuery 中 $.fn.extend 函数的实现（实现核心代码即可）"></a>2. JQuery 中 $.fn.extend 函数的实现（实现核心代码即可）</h2><p><a href="https://segmentfault.com/a/1190000005895616" target="_blank" rel="noopener">参考一</a></p>
<h2 id="3-伪元素和伪类的区别"><a href="#3-伪元素和伪类的区别" class="headerlink" title="3. 伪元素和伪类的区别"></a>3. 伪元素和伪类的区别</h2><h3 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h3><p>伪类存在的意义是为了通过选择器找到那些不存在与DOM树中的信息以及不能被常规CSS选择器获取到的信息。</p>
<p>伪类由一个冒号:开头，冒号后面是伪类的名称和包含在圆括号中的可选参数。</p>
<p>任何常规选择器可以再任何位置使用伪类。伪类语法不区别大小写。一些伪类的作用会互斥，另外一些伪类可以同时被同一个元素使用。并且，为了满足用户在操作DOM时产生的DOM结构改变，伪类也可以是动态的。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes" target="_blank" rel="noopener">标准伪类索引</a></p>
<p>:active<br>:any<br>:checked<br>:default<br>:dir()<br>:disabled<br>:empty<br>:enabled<br>:first<br>:first-child<br>:first-of-type<br>:fullscreen<br>:focus<br>:hover<br>:indeterminate<br>:in-range<br>:invalid<br>:lang()<br>:last-child<br>:last-of-type<br>:left<br>:link<br>:not()<br>:nth-child()<br>:nth-last-child()<br>:nth-last-of-type()<br>:nth-of-type()<br>:only-child<br>:only-of-type<br>:optional<br>:out-of-range<br>:read-only<br>:read-write<br>:required<br>:right<br>:root<br>:scope<br>:target<br>:valid<br>:visited</p>
<h3 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h3><p>伪元素在DOM树中创建了一些抽象元素，这些抽象元素是不存在于文档语言里的（可以理解为html源码）。比如：documen接口不提供访问元素内容的第一个字或者第一行的机制，而伪元素可以使开发者可以提取到这些信息。并且，一些伪元素可以使开发者获取到不存在于源文档中的内容（比如常见的::before,::after）。</p>
<p>伪元素的由两个冒号::开头，然后是伪元素的名称。</p>
<p>使用两个冒号::是为了区别伪类和伪元素（CSS2中并没有区别）。当然，考虑到兼容性，CSS2中已存的伪元素仍然可以使用一个冒号:的语法，但是CSS3中新增的伪元素必须使用两个冒号::。</p>
<p>一个选择器只能使用一个伪元素，并且伪元素必须处于选择器语句的最后。</p>
<p>注：不排除未来会加入同时使用多个伪元素的机制。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-elements" target="_blank" rel="noopener">所有伪元素</a></p>
<p>::after<br>::before<br>::first-letter<br>::first-line<br>::selection</p>
<h2 id="4-找出整形数组中乘积最大的三个数"><a href="#4-找出整形数组中乘积最大的三个数" class="headerlink" title="4. 找出整形数组中乘积最大的三个数"></a>4. 找出整形数组中乘积最大的三个数</h2>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/11/你不知道的js笔记-this和原型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雯子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Athena">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/11/你不知道的js笔记-this和原型/" itemprop="url">
                  你不知道的js笔记-this和原型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-04-11 11:06:01" itemprop="dateCreated datePublished" datetime="2017-04-11T11:06:01+08:00">2017-04-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-04-14 11:25:17" itemprop="dateModified" datetime="2017-04-14T11:25:17+08:00">2017-04-14</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="this的调用"><a href="#this的调用" class="headerlink" title="this的调用"></a>this的调用</h2><p>每个函数的this是在调用时被绑定的，完全取决于函数的调用位置，也就是函数的调用方法。<br>那么就要分析调用栈，可以用浏览器的调试工具查看调用栈。打断点后，显示的调用栈的第二个元素，就是真正的调用位置。</p>
<h3 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h3><h4 id="1-默认绑定"><a href="#1-默认绑定" class="headerlink" title="1. 默认绑定"></a>1. 默认绑定</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">funciton foo()&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">foo(); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>如果使用严格模式，则不能将全局对象用于默认绑定，因此this会绑定到undefined</p>
<h4 id="2-隐式绑定"><a href="#2-隐式绑定" class="headerlink" title="2. 隐式绑定"></a>2. 隐式绑定</h4><p>在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把this间接（隐式）绑定到这个对象上。<br>当函数引用有上下文对象时，隐式绑定规则会把函数调用中的this绑定到这个上下文对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">funciton foo() &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo(); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<h4 id="3-显式绑定"><a href="#3-显式绑定" class="headerlink" title="3. 显式绑定"></a>3. 显式绑定</h4><p>call(…)和apply(…)<br>它们的第一个参数是一个对象，是给this准备的，接着在调用函数时将其绑定到this。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">funciton foo() &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line">foo.call(obj); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>如果传入了一个原始值，也就是字符串类型、布尔类型或者数字类型来当做this的绑定对象，这个原始值会被转换成它的对象形式，也就是new String(…), new Boolean(…), new Number(…)</p>
<h5 id="3-1-硬绑定"><a href="#3-1-硬绑定" class="headerlink" title="3.1 硬绑定"></a>3.1 硬绑定</h5><p>ES5提供了内置的方法Function.prototype.bind，它的用法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a, something);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.a + something;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.bind(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = bar (<span class="number">3</span>); <span class="comment">//2 3</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//5</span></span><br></pre></td></tr></table></figure>
<p>bind会返回一个硬解码的新函数，它会把你指定的参数设置为this的上下文并调用原始函数。</p>
<h5 id="3-2-API调用的上下文"><a href="#3-2-API调用的上下文" class="headerlink" title="3.2 API调用的上下文"></a>3.2 API调用的上下文</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fonction foo(el) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(el, <span class="keyword">this</span>.id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  id: <span class="string">"awesome"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用foo(...)时把this绑定到obj</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach(foo, obj)</span><br></pre></td></tr></table></figure>
<h4 id="4-new绑定"><a href="#4-new绑定" class="headerlink" title="4. new绑定"></a>4. new绑定</h4>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/10/你不知道的js第五章笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雯子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Athena">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/10/你不知道的js第五章笔记/" itemprop="url">
                  你不知道的js第五章笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-04-10 11:06:56" itemprop="dateCreated datePublished" datetime="2017-04-10T11:06:56+08:00">2017-04-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-04-14 11:25:10" itemprop="dateModified" datetime="2017-04-14T11:25:10+08:00">2017-04-14</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="作用域闭包"><a href="#作用域闭包" class="headerlink" title="作用域闭包"></a>作用域闭包</h2><p>首先是闭包的定义：</p>
<blockquote>
<p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。</p>
</blockquote>
<p>无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包。</p>
<p>本质上无论何时何地，如果将（访问它们各自词法作用域的）函数当做第一级的值类型并到处传递，就会看到闭包在这些函数的应用。例如定时器、事件监听器、ajax请求、跨窗口通信等，只要使用了毁掉函数，实际上就是在使用闭包。</p>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>模块模式需要具备两个必要条件：</p>
<ol>
<li>必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）</li>
<li>封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。</li>
</ol>
<p>es6的模块没有“行内”格式，必须被定义在独立的文件中，即一个文件一个模块。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="雯子" />
            
              <p class="site-author-name" itemprop="name">雯子</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/athena0304" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright"> &copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">雯子</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Pisces</a> v6.4.2</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.2"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.2"></script>



  



  










  





  

  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
