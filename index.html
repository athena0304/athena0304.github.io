<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.2" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.2">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.2" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.4.2',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="Athena">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Athena">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Athena">






  <link rel="canonical" href="http://yoursite.com/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Athena</title>
  






  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?15fcb8c2aa27ecb358060d2600aa2502";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Athena</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">雯子写字的地方</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    
  
  
  
    
      
    
    <a href="https://github.com/athena0304" class="github-corner" target="_blank" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#222; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg>
    
      </a>
    



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/19/日本之海游馆/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雯子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Athena">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/19/日本之海游馆/" itemprop="url">
                  日本之海游馆
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-19 16:13:52 / 修改时间：16:19:58" itemprop="dateCreated datePublished" datetime="2018-11-19T16:13:52+08:00">2018-11-19</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前前后后去了五次日本了，总觉得该捋一捋。然而说吃的吧，感觉太多了，不好整理，就先从海游馆下手吧。</p>
<p>雯子前后去了日本的三个海游馆，分别是大阪海游馆、福冈海洋世界海之中道、鹿儿岛海游馆。每个海游馆都很有特色，体验绝对是我在国内没体验过的。</p>
<p>国内近两年我去过大连和青岛的两个海洋馆，看过之后除了对企鹅印象很深以外，别的都记不得了。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/16/vue-markdown-loader源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雯子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Athena">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/16/vue-markdown-loader源码解析/" itemprop="url">
                  vue-markdown-loader源码解析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-16 11:48:15" itemprop="dateCreated datePublished" datetime="2018-11-16T11:48:15+08:00">2018-11-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-11-28 12:18:34" itemprop="dateModified" datetime="2018-11-28T12:18:34+08:00">2018-11-28</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>项目中遇到了需要单独加载某个 markdown 文件显示在页面中，类似于操作指引的感觉，于是找到了 vue-markdown-loader 这个工具，觉得很好用，于是我打算开个专题看一下里面都做了些什么，有助于对 webpack loader 的理解。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>这里需要先了解 webpack loader 的原理，后面的代码需要配合 webpack 的<a href="https://webpack.js.org/api/loaders/" target="_blank" rel="noopener">官网</a>对照着来看。中文版在<a href="https://webpack.docschina.org/concepts/loaders" target="_blank" rel="noopener">这里</a>。</p>
<p>首先我们需要知道 loader 是什么，那么 loader 其实就是一个 JavaScript module，导出的是一个函数。<a href="https://github.com/webpack/loader-runner" target="_blank" rel="noopener">loader runner</a> 会调用这个函数，将前一个 loader 执行的结果或者源文件作为参数传递进来。函数中的 this 上下文由 webpack 填充，loader runner 有一些实用的方法可以允许 loader 改变其触发方式为异步，或者获取 query 参数。</p>
<p>在这里摘录一下 loader 的特性：</p>
<ul>
<li>loader 支持链式传递。loader 链中每个 loader，都对前一个 loader 处理后的资源进行转换。loader 链会按照相反的顺序执行。第一个 loader 将（应用转换后的资源作为）返回结果传递给下一个 loader，依次这样执行下去。最终，在链中最后一个 loader，返回 webpack 所预期的 JavaScript。</li>
<li>loader 可以是同步的，也可以是异步的。</li>
<li>loader 运行在 Node.js 中，并且能够执行任何可能的操作。</li>
<li>loader 接收查询参数。用于对 loader 传递配置。</li>
<li>loader 也能够使用 <code>options</code> 对象进行配置。</li>
<li>除了使用 <code>package.json</code> 常见的 <code>main</code> 属性，还可以将普通的 npm 模块导出为 loader，做法是在 <code>package.json</code> 里定义一个 <code>loader</code> 字段。</li>
<li>插件(plugin)可以为 loader 带来更多特性。</li>
<li>loader 能够产生额外的任意文件。</li>
</ul>
<p>了解原理之后，我们还要再看一篇文档，<a href="https://webpack.docschina.org/contribute/writing-a-loader/" target="_blank" rel="noopener">如何编写一个loader</a>。</p>
<h3 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h3><p>如果你想更方便的调试代码，需要配置一下调试环境，这里我用的 VSCode 自带的调试工具（我找了一圈现阶段觉得这种方式最靠谱）</p>
<p>在 debug 模式下点击配置按钮，就会生成一个 <code>.vscode/launch.json</code> 的文件，里面的配置改成如下即可：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"node"</span>,</span><br><span class="line">      <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"启动程序"</span>,</span><br><span class="line">      <span class="attr">"program"</span>: <span class="string">"$&#123;workspaceFolder&#125;/node_modules/webpack/bin/webpack.js"</span>,</span><br><span class="line">      <span class="attr">"cwd"</span>: <span class="string">"$&#123;workspaceFolder&#125;/example"</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其中 program 设置成 webpack 本身的文件执行的位置，cwd 设置成执行 webpack 所在的根目录。点击启动程序按钮就可以断点调试了，想看啥看啥。</p>
<p>下面就可以开始看源码了。</p>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>首先看下目录结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── example</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   ├── src</span><br><span class="line">│   │   ├── app.vue</span><br><span class="line">│   │   ├── custom.css</span><br><span class="line">│   │   ├── entry.js</span><br><span class="line">│   │   └── markdown.md</span><br><span class="line">│   └── webpack.config.js</span><br><span class="line">├── index.js</span><br><span class="line">├── lib</span><br><span class="line">│   ├── core.js</span><br><span class="line">│   └── markdown-compiler.js</span><br><span class="line">├── package-lock.json</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure>
<p>结构很清晰，东西也不算太多，涉及到的源码就是 <code>index.js</code>和 <code>lib</code> 下的两个 js 文件，<code>example</code> 里面的是示例。</p>
<p>那我们就先从 <code>index.js</code> 开始看起吧。</p>
<p>就一句话：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">require</span>(<span class="string">'./lib/core'</span>);</span><br></pre></td></tr></table></figure>
<p>这个文件是你引入这个包的入口，这里直接去找的 <code>./lib/core</code>，于是我们继续去 <code>./lib/core</code> 看看。</p>
<h3 id="core-js"><a href="#core-js" class="headerlink" title="core.js"></a>core.js</h3><p>在声明阶段：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">var</span> loaderUtils = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> markdownCompilerPath = path.resolve(__dirname, <span class="string">'markdown-compiler.js'</span>);</span><br></pre></td></tr></table></figure>
<p>这里引用了 <a href="https://www.npmjs.com/package/loader-utils" target="_blank" rel="noopener">loader-utils</a> 和同级目录下的 <code>markdown-compiler.js</code></p>
<p>在这里我们逐行解析 <code>core.js</code> 里面的代码，遇到什么就去查什么。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// （1）是否可缓存</span></span><br><span class="line">  <span class="keyword">this</span>.cacheable(); </span><br><span class="line">  <span class="comment">// （2）获取 options </span></span><br><span class="line">  <span class="keyword">var</span> options = loaderUtils.getOptions(<span class="keyword">this</span>) || &#123;&#125;; </span><br><span class="line">  <span class="comment">// （3）为 Compilation 对象添加 __vueMarkdownOptions__ 属性</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>._compilation, <span class="string">'__vueMarkdownOptions__'</span>, &#123;</span><br><span class="line">    value: options,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// (4) 获取资源文件的路径</span></span><br><span class="line">  <span class="keyword">var</span> filePath = <span class="keyword">this</span>.resourcePath;</span><br><span class="line">  <span class="comment">// (5) 生成 result</span></span><br><span class="line">  <span class="keyword">var</span> result =</span><br><span class="line">    <span class="string">'module.exports = require('</span> +</span><br><span class="line">    loaderUtils.stringifyRequest(</span><br><span class="line">      <span class="keyword">this</span>,</span><br><span class="line">      <span class="string">'!!vue-loader!'</span> +</span><br><span class="line">        markdownCompilerPath +</span><br><span class="line">        <span class="string">'?raw!'</span> +</span><br><span class="line">        filePath +</span><br><span class="line">        (<span class="keyword">this</span>.resourceQuery || <span class="string">''</span>)</span><br><span class="line">    ) +</span><br><span class="line">    <span class="string">');'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(result)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>首先可以看到这个文件最后是导出了一个 result，参数传进来的是 source，也就是之前 loader 产生过的结果或者是源文件，有个上下文 this。</p>
<p><strong>（1）是否可缓存</strong></p>
<p><code>this.cacheable();</code> 对应的是<a href="https://webpack.docschina.org/api/loaders/#this-cacheable" target="_blank" rel="noopener">是否可缓存</a>。</p>
<blockquote>
<p>默认情况下，loader 的处理结果会被标记为可缓存。调用这个方法然后传入 <code>false</code>，可以关闭 loader 的缓存。</p>
<p>一个可缓存的 loader 在输入和相关依赖没有变化时，必须返回相同的结果。这意味着 loader 除了 <code>this.addDependency</code> 里指定的以外，不应该有其它任何外部依赖。</p>
</blockquote>
<p><strong>（2）获取 options</strong> </p>
<p>参考 loader-utils 的<a href="https://www.npmjs.com/package/loader-utils#getoptions" target="_blank" rel="noopener">文档</a></p>
<p>是检索调用 loader 的 options 的推荐方式。</p>
<p>本文中为<code>{}</code></p>
<p><strong>（3）为 Compilation 对象添加<code>__vueMarkdownOptions__</code> 属性</strong></p>
<p><strong>（4）获取资源文件的路径</strong></p>
<p>获取到的路径是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;vue-markdown-loader/example/src/markdown.md&quot;</span><br></pre></td></tr></table></figure>
<p><strong>（5）生成 result</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;module.exports = require(&quot;!!vue-loader!../../lib/markdown-compiler.js?raw!./markdown.md&quot;);&quot;</span><br></pre></td></tr></table></figure>
<p><strong>参数 source</strong></p>
<p>这里传进来的 source 就是原始文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;# Hello`&lt;span&gt;&#123;&#123;sss&#125;&#125;&lt;/span&gt;`&gt; This is test.- How are you?- Fine, Thank you, and you?- I&apos;m fine， too. Thank you.- 🌚```javascriptimport Vue from &apos;vue&apos;Vue.config.debug = true```&lt;div class=&quot;test&quot;&gt;  &#123;&#123; model &#125;&#125; test&lt;/div&gt;&lt;compo&gt;&#123;&#123; model &#125;&#125;&lt;/compo&gt;&lt;div  class=&quot;abc&quot;  @click=&quot;show = false&quot;&gt;  啊哈哈哈&lt;/div&gt;&gt; All script or style tags in html mark will be extracted.Script will be excuted, and style will be added to document head.&gt; Notice if there is a string instance which contains special word &quot;&amp;lt;/script&gt;&quot;, it will fetch a SyntaxError.&gt; Due to the complexity to solve it, just don&apos;t do that.```html&lt;style scoped&gt;  .test &#123;    background-color: green;  &#125;&lt;/style&gt;&lt;style scoped&gt;  .abc &#123;    background-color: yellow;  &#125;&lt;/style&gt;&lt;script&gt;  let a=1&lt;2;  let b=&quot;&lt;-forget it-/script&gt;&quot;;  console.log(&quot;***This script tag is successfully extracted and excuted.***&quot;)  module.exports = &#123;    components: &#123;      compo: &#123;        render(h) &#123;          return h(&apos;div&apos;, &#123;            style: &#123;              background: &apos;red&apos;            &#125;          &#125;, this.$slots.default);        &#125;      &#125;    &#125;,    data () &#123;      return &#123;        model: &apos;abc&apos;      &#125;    &#125;  &#125;&lt;/script&gt;jjjjjjjjjjjjjjjjjjjjjj&lt;template&gt;  &lt;div&gt;&lt;/div&gt;&lt;/template&gt;```&lt;div&gt;&lt;/div&gt;sadfsfs大家哦哦好啊谁都发生地方上的冯绍峰s&gt; sahhhh&lt;compo&gt;&#123;&#123; model &#125;&#125;&lt;/compo&gt;```html&lt;compo&gt;&#123;&#123;model &#125;&#125;&#123;&#123;model &#125;&#125;&#123;&#123;model &#125;&#125;&#123;&#123;model &#125;&#125;&#123;&#123; model &#125;&#125;&lt;/compo&gt;```&lt;style src=&quot;./custom.css&quot;&gt;&lt;/style&gt;## 引入 style 文件&lt;div class=&quot;custom&quot;&gt;  原谅色&lt;/div&gt;&quot;</span><br></pre></td></tr></table></figure>
<p>通过 require 里的参数，我们知道，这个 vue-markdown-loader loader 首先会加载 <code>.md</code> 文件，然后通过 <code>markdown-compiler.js?raw</code> 来处理该文件，再通过 <code>vue-loader</code> 处理。</p>
<p>所以我们需要继续去 <code>markdown-compiler.js</code> 里一探究竟。</p>
<h3 id="markdown-compiler-js"><a href="#markdown-compiler-js" class="headerlink" title="markdown-compiler.js"></a>markdown-compiler.js</h3><p>首先我们看一下引入声明部分：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loaderUtils = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>);</span><br><span class="line"><span class="keyword">var</span> hljs = <span class="built_in">require</span>(<span class="string">'highlight.js'</span>);</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>);</span><br><span class="line"><span class="keyword">var</span> markdown = <span class="built_in">require</span>(<span class="string">'markdown-it'</span>);</span><br><span class="line"><span class="keyword">var</span> Token = <span class="built_in">require</span>(<span class="string">'markdown-it/lib/token'</span>);</span><br></pre></td></tr></table></figure>
<p>再看下面的代码之前，有必要了解一下上面引入的东西</p>
<h4 id="markdown-it"><a href="#markdown-it" class="headerlink" title="markdown-it"></a><a href="https://www.npmjs.com/package/markdown-it" target="_blank" rel="noopener">markdown-it</a></h4><p>将 markdown 转换成 html 的本尊。</p>
<p>有两种使用方式：render函数和传递 options</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node.js, "classic" way:</span></span><br><span class="line"><span class="keyword">var</span> MarkdownIt = <span class="built_in">require</span>(<span class="string">'markdown-it'</span>),</span><br><span class="line">    md = <span class="keyword">new</span> MarkdownIt();</span><br><span class="line"><span class="keyword">var</span> result = md.render(<span class="string">'# markdown-it rulezz!'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// node.js, the same, but with sugar:</span></span><br><span class="line"><span class="keyword">var</span> md = <span class="built_in">require</span>(<span class="string">'markdown-it'</span>)();</span><br><span class="line"><span class="keyword">var</span> result = md.render(<span class="string">'# markdown-it rulezz!'</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// full options list (defaults)</span></span><br><span class="line"><span class="keyword">var</span> md = <span class="built_in">require</span>(<span class="string">'markdown-it'</span>)(&#123;</span><br><span class="line">  html:         <span class="literal">false</span>,        <span class="comment">// Enable HTML tags in source</span></span><br><span class="line">  xhtmlOut:     <span class="literal">false</span>,        <span class="comment">// Use '/' to close single tags (&lt;br /&gt;).</span></span><br><span class="line">                              <span class="comment">// This is only for full CommonMark compatibility.</span></span><br><span class="line">  breaks:       <span class="literal">false</span>,        <span class="comment">// Convert '\n' in paragraphs into &lt;br&gt;</span></span><br><span class="line">  langPrefix:   <span class="string">'language-'</span>,  <span class="comment">// CSS language prefix for fenced blocks. Can be</span></span><br><span class="line">                              <span class="comment">// useful for external highlighters.</span></span><br><span class="line">  linkify:      <span class="literal">false</span>,        <span class="comment">// Autoconvert URL-like text to links</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Enable some language-neutral replacement + quotes beautification</span></span><br><span class="line">  typographer:  <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Double + single quotes replacement pairs, when typographer enabled,</span></span><br><span class="line">  <span class="comment">// and smartquotes on. Could be either a String or an Array.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// For example, you can use '«»„“' for Russian, '„“‚‘' for German,</span></span><br><span class="line">  <span class="comment">// and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).</span></span><br><span class="line">  quotes: <span class="string">'“”‘’'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Highlighter function. Should return escaped HTML,</span></span><br><span class="line">  <span class="comment">// or '' if the source string is not changed and should be escaped externaly.</span></span><br><span class="line">  <span class="comment">// If result starts with &lt;pre... internal wrapper is skipped.</span></span><br><span class="line">  highlight: <span class="function"><span class="keyword">function</span> (<span class="params"><span class="regexp">/*str, lang*/</span></span>) </span>&#123; <span class="keyword">return</span> <span class="string">''</span>; &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="highlight-js"><a href="#highlight-js" class="headerlink" title="highlight.js"></a><a href="https://highlightjs.org/" target="_blank" rel="noopener">highlight.js</a></h4><p>语法高亮工具</p>
<h4 id="cheerio"><a href="#cheerio" class="headerlink" title="cheerio"></a><a href="https://www.npmjs.com/package/cheerio" target="_blank" rel="noopener">cheerio</a></h4><p>Fast, flexible &amp; lean implementation of core jQuery designed specifically for the server.</p>
<p>接下来，我们先看几个声明的函数：</p>
<h4 id="addVuePreviewAttr"><a href="#addVuePreviewAttr" class="headerlink" title="addVuePreviewAttr"></a>addVuePreviewAttr</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * `&lt;pre&gt;&lt;/pre&gt;` =&gt; `&lt;pre v-pre&gt;&lt;/pre&gt;`</span></span><br><span class="line"><span class="comment"> * `&lt;code&gt;&lt;/code&gt;` =&gt; `&lt;code v-pre&gt;&lt;/code&gt;`</span></span><br><span class="line"><span class="comment"> * @param  &#123;string&#125; str</span></span><br><span class="line"><span class="comment"> * @return &#123;string&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> addVuePreviewAttr = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.replace(<span class="regexp">/(&lt;pre|&lt;code)/g</span>, <span class="string">'$1 v-pre'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个函数就是查找 html 标签中所有 <code>&lt;pre</code> 或者 <code>&lt;code</code>，替换成  <code>&lt;pre v-pre</code> 和 <code>&lt;code v-pre</code></p>
<h4 id="renderHighlight"><a href="#renderHighlight" class="headerlink" title="renderHighlight"></a>renderHighlight</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * renderHighlight</span></span><br><span class="line"><span class="comment"> * @param  &#123;string&#125; str</span></span><br><span class="line"><span class="comment"> * @param  &#123;string&#125; lang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> renderHighlight = <span class="function"><span class="keyword">function</span>(<span class="params">str, lang</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(lang &amp;&amp; hljs.getLanguage(lang))) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> hljs.highlight(lang, str, <span class="literal">true</span>).value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>返回通过 highlight.js 高亮后的数据</p>
<h4 id="renderVueTemplate"><a href="#renderVueTemplate" class="headerlink" title="renderVueTemplate"></a>renderVueTemplate</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * html =&gt; vue file template</span></span><br><span class="line"><span class="comment"> * @param  &#123;[type]&#125; html [description]</span></span><br><span class="line"><span class="comment"> * @return &#123;[type]&#125;      [description]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> renderVueTemplate = <span class="function"><span class="keyword">function</span>(<span class="params">html, wrapper</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 用 cheerio 提取参数传进来的要进行处理的 html</span></span><br><span class="line">  <span class="keyword">var</span> $ = cheerio.load(html, &#123;</span><br><span class="line">    decodeEntities: <span class="literal">false</span>, <span class="comment">// 是否解码文档实体，默认为 false</span></span><br><span class="line">    lowerCaseAttributeNames: <span class="literal">false</span>, <span class="comment">// 是否将所有属性名设置成小写，会对速度有影响，默认为 false</span></span><br><span class="line">    lowerCaseTags: <span class="literal">false</span> <span class="comment">// 是否将所有标签转换成小写</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 将原 html 中的 style 和第一个 script 标签缓存起来</span></span><br><span class="line">  <span class="keyword">var</span> output = &#123;</span><br><span class="line">    style: $.html(<span class="string">'style'</span>),</span><br><span class="line">    <span class="comment">// get only the first script child. Causes issues if multiple script files in page.</span></span><br><span class="line">    script: $.html($(<span class="string">'script'</span>).first())</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> result;</span><br><span class="line"></span><br><span class="line">  $(<span class="string">'style'</span>).remove();</span><br><span class="line">  $(<span class="string">'script'</span>).remove();</span><br><span class="line">  <span class="comment">// 生成最后的结果</span></span><br><span class="line">  result =</span><br><span class="line">    <span class="string">`&lt;template&gt;&lt;<span class="subst">$&#123;wrapper&#125;</span>&gt;`</span> +</span><br><span class="line">    $.html() +</span><br><span class="line">    <span class="string">`&lt;/<span class="subst">$&#123;wrapper&#125;</span>&gt;&lt;/template&gt;\n`</span> +</span><br><span class="line">    output.style +</span><br><span class="line">    <span class="string">'\n'</span> +</span><br><span class="line">    output.script;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是整个 loader 的核心功能，就是把 html 包裹一层 vue 的语法变成一个 vue 的组件，然后再让后面的 vue-loader 接收。这里用到了 cheerio 来做一些简单的 DOM 操作。</p>
<p>说完了函数声明，就继续来看整个处理过程：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// (1) 是否可缓存</span></span><br><span class="line">  <span class="keyword">this</span>.cacheable &amp;&amp; <span class="keyword">this</span>.cacheable();</span><br><span class="line">  <span class="keyword">var</span> parser, preprocess;</span><br><span class="line">  <span class="comment">// （2）获取参数，此时把外面传进来的解析成 Object &#123;raw: true&#125;(来自core.js)</span></span><br><span class="line">  <span class="keyword">var</span> params = loaderUtils.getOptions(<span class="keyword">this</span>) || &#123;&#125;;</span><br><span class="line">  <span class="comment">// （3）获取 __vueMarkdownOptions__(来自core.js)</span></span><br><span class="line">  <span class="keyword">var</span> vueMarkdownOptions = <span class="keyword">this</span>._compilation.__vueMarkdownOptions__;</span><br><span class="line">  <span class="comment">// （4）继承 vueMarkdownOptions 的原型，赋值给opts</span></span><br><span class="line">  <span class="keyword">var</span> opts = vueMarkdownOptions ? <span class="built_in">Object</span>.create(vueMarkdownOptions.__proto__) : &#123;&#125;; <span class="comment">// inherit prototype</span></span><br><span class="line">  <span class="keyword">var</span> preventExtract = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// （5）合并所有来源的参数、属性，汇总给opts</span></span><br><span class="line">  opts = <span class="built_in">Object</span>.assign(opts, params, vueMarkdownOptions); <span class="comment">// assign attributes</span></span><br><span class="line">  <span class="comment">// （6）判断 options 中 preventExtract 是都为 true</span></span><br><span class="line">  <span class="keyword">if</span> (opts.preventExtract) &#123;</span><br><span class="line">    <span class="keyword">delete</span> opts.preventExtract;</span><br><span class="line">    preventExtract = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// （7）判断 options 中 render 的类型</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> opts.render === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="comment">// （8）如果是 function，parser 就是 opts</span></span><br><span class="line">    parser = opts;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// （9）如果不是 function，为 opts 添加一些属性，以及后面的一系列操作。opts 最后是作为 option 传入 markdown-it 中的。</span></span><br><span class="line">    opts = <span class="built_in">Object</span>.assign(</span><br><span class="line">      &#123;</span><br><span class="line">        preset: <span class="string">'default'</span>,</span><br><span class="line">        html: <span class="literal">true</span>,</span><br><span class="line">        highlight: renderHighlight,</span><br><span class="line">        wrapper: <span class="string">'section'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      opts</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// （10）初始化 插件 plugins</span></span><br><span class="line">    <span class="keyword">var</span> plugins = opts.use;</span><br><span class="line">    <span class="comment">// （11）初始化 预处理 preprocess</span></span><br><span class="line">    preprocess = opts.preprocess;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> opts.use;</span><br><span class="line">    <span class="keyword">delete</span> opts.preprocess;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// （12）在这里初始化 markdown-it</span></span><br><span class="line">    parser = markdown(opts.preset, opts);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// （13）添加 ruler：从 html token 中提取 script 和 style</span></span><br><span class="line">    <span class="comment">//add ruler:extract script and style tags from html token content</span></span><br><span class="line">    !preventExtract &amp;&amp;</span><br><span class="line">      parser.core.ruler.push(<span class="string">'extract_script_or_style'</span>, <span class="function"><span class="keyword">function</span> <span class="title">replace</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        state</span></span></span><br><span class="line"><span class="function"><span class="params">      </span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> tag_reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'&lt;(script|style)(?:[^&lt;]|&lt;)+&lt;/\\1&gt;'</span>, <span class="string">'g'</span>);</span><br><span class="line">        <span class="keyword">let</span> newTokens = [];</span><br><span class="line">        state.tokens</span><br><span class="line">          .filter(<span class="function"><span class="params">token</span> =&gt;</span> token.type == <span class="string">'fence'</span> &amp;&amp; token.info == <span class="string">'html'</span>)</span><br><span class="line">          .forEach(<span class="function"><span class="params">token</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> tokens = (token.content.match(tag_reg) || []).map(<span class="function"><span class="params">content</span> =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> t = <span class="keyword">new</span> Token(<span class="string">'html_block'</span>, <span class="string">''</span>, <span class="number">0</span>);</span><br><span class="line">              t.content = content;</span><br><span class="line">              <span class="keyword">return</span> t;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span> (tokens.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              newTokens.push.apply(newTokens, tokens);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        state.tokens.push.apply(state.tokens, newTokens);</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="comment">// （14）如果有插件，就应用一下</span></span><br><span class="line">    <span class="keyword">if</span> (plugins) &#123;</span><br><span class="line">      plugins.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">plugin</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(plugin)) &#123;</span><br><span class="line">          parser.use.apply(parser, plugin);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          parser.use(plugin);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// （15）覆盖默认的 parser rules，在 'code' 和 'pre' 标签上添加 v-pre 属性</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * override default parser rules by adding v-pre attribute on 'code' and 'pre' tags</span></span><br><span class="line"><span class="comment">   * @param &#123;Array&lt;string&gt;&#125; rules rules to override</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">overrideParserRules</span>(<span class="params">rules</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parser &amp;&amp; parser.renderer &amp;&amp; parser.renderer.rules) &#123;</span><br><span class="line">      <span class="keyword">var</span> parserRules = parser.renderer.rules;</span><br><span class="line">      rules.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">rule</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parserRules &amp;&amp; parserRules[rule]) &#123;</span><br><span class="line">          <span class="keyword">var</span> defaultRule = parserRules[rule];</span><br><span class="line">          parserRules[rule] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> addVuePreviewAttr(defaultRule.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>));</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// （16）覆盖这三种默认规则</span></span><br><span class="line">  overrideParserRules([<span class="string">'code_inline'</span>, <span class="string">'code_block'</span>, <span class="string">'fence'</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// （17）如果有预处理，执行一下</span></span><br><span class="line">  <span class="keyword">if</span> (preprocess) &#123;</span><br><span class="line">    source = preprocess.call(<span class="keyword">this</span>, parser, source);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// （18）将 source 中所有的 @ 替换成 '__at__'</span></span><br><span class="line">  source = source.replace(<span class="regexp">/@/g</span>, <span class="string">'__at__'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> content = parser.render(source).replace(<span class="regexp">/__at__/g</span>, <span class="string">'@'</span>);</span><br><span class="line">  <span class="keyword">var</span> result = renderVueTemplate(content, opts.wrapper);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (opts.raw) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'module.exports = '</span> + <span class="built_in">JSON</span>.stringify(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/Users/athena/Library/Application Support/typora-user-images/image-20181121120525127.png" alt="image-20181121120525127"></p>
<p><strong>（6）preventExtract</strong></p>
<p>preventExtract 是 vue-markdown-loader 提供的一个<a href="https://www.npmjs.com/package/vue-markdown-loader?activeTab=readme#preventextract" target="_blank" rel="noopener">选项</a></p>
<blockquote>
<p>Since <code>v2.0.0</code>, this loader will automatically extract script and style tags from html token content (#26). If you do not need, you can set this option</p>
</blockquote>
<p><strong>（13）添加 ruler：从 html token 中提取 script 和 style</strong></p>
<p>走到这里，就需要对 token 有一个认识才行，所以建议先看一下<a href="https://www.jianshu.com/p/fb0ee355915c" target="_blank" rel="noopener">这篇文章</a>。我摘录一部分：</p>
<blockquote>
<p>当你创建了一个 <code>md = require(&#39;markdown-it&#39;)()</code> 对象之后，就可以用它来渲染 MD 文档了，例如: <code>md.render(&quot;# I&#39;m H1 &quot;)</code>。这个渲染过程分为主要的两步:</p>
<ol>
<li>将 MD 文档 Parsing 为 Tokens。</li>
<li>渲染这个 Tokens。</li>
</ol>
<p>Parsing 的过程是，首先创建一个 Core Parser，这个 Core Parser 包含一系列的缺省 Rules。这些 Rules 将顺序执行，每个 Rule 都在前面的 Tokens 的基础上，要么修改原来的 Token，要么添加新的 Token。这个 Rules 的链条被称为 Core Chain。</p>
<p>在所有 Tokens 都获得之后，就可以渲染了。渲染就是把特定 Token 转变为特定的 HTML 的过程。</p>
<p>Markdown-It 允许你为特定的 Token Type 挂载自己的渲染函数，这个函数称为 Renderer Rule。Markdown-It 已经定义了几个 缺省的 Renderer Rules</p>
</blockquote>
<p><strong>（14）如果有插件，就应用一下</strong></p>
<p><a href="https://markdown-it.github.io/markdown-it/#MarkdownIt.use" target="_blank" rel="noopener">MarkdownIt.use</a></p>
<p>在当前的解析实例中应用指定的插件。</p>
<p>最终输出的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&lt;template&gt;&lt;section&gt;&lt;h1&gt;Hello&lt;/h1&gt;&lt;p&gt;&lt;code v-pre=&quot;&quot;&gt;&amp;lt;span&amp;gt;&#123;&#123;sss&#125;&#125;&amp;lt;/span&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;This is test.&lt;/p&gt;&lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;How are you?&lt;/li&gt;&lt;li&gt;Fine, Thank you, and you?&lt;/li&gt;&lt;li&gt;I&apos;m fine， too. Thank you.&lt;/li&gt;&lt;li&gt;🌚&lt;/li&gt;&lt;/ul&gt;&lt;pre v-pre=&quot;&quot;&gt;&lt;code v-pre=&quot;&quot; class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; Vue &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&apos;vue&apos;&lt;/span&gt;Vue.config.debug = &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;div class=&quot;test&quot;&gt;  &#123;&#123; model &#125;&#125; test&lt;/div&gt;&lt;p&gt;&lt;compo&gt;&#123;&#123; model &#125;&#125;&lt;/compo&gt;&lt;/p&gt;&lt;div class=&quot;abc&quot; @click=&quot;show = false&quot;&gt;  啊哈哈哈&lt;/div&gt;&lt;blockquote&gt;&lt;p&gt;All script or style tags in html mark will be extracted.Script will be excuted, and style will be added to document head.Notice if there is a string instance which contains special word &amp;quot;&amp;lt;/script&amp;gt;&amp;quot;, it will fetch a SyntaxError.Due to the complexity to solve it, just don&apos;t do that.&lt;/p&gt;&lt;/blockquote&gt;&lt;pre v-pre=&quot;&quot;&gt;&lt;code v-pre=&quot;&quot; class=&quot;language-html&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;style&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;scoped&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;css&quot;&gt;  &lt;span class=&quot;hljs-selector-class&quot;&gt;.test&lt;/span&gt; &#123;    &lt;span class=&quot;hljs-attribute&quot;&gt;background-color&lt;/span&gt;: green;  &#125;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;style&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;style&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;scoped&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;css&quot;&gt;  &lt;span class=&quot;hljs-selector-class&quot;&gt;.abc&lt;/span&gt; &#123;    &lt;span class=&quot;hljs-attribute&quot;&gt;background-color&lt;/span&gt;: yellow;  &#125;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;style&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;javascript&quot;&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; a=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;  &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; b=&lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;lt;-forget it-/script&amp;gt;&quot;&lt;/span&gt;;  &lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;hljs-string&quot;&gt;&quot;***This script tag is successfully extracted and excuted.***&quot;&lt;/span&gt;)  &lt;span class=&quot;hljs-built_in&quot;&gt;module&lt;/span&gt;.exports = &#123;    &lt;span class=&quot;hljs-attr&quot;&gt;components&lt;/span&gt;: &#123;      &lt;span class=&quot;hljs-attr&quot;&gt;compo&lt;/span&gt;: &#123;        render(h) &#123;          &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; h(&lt;span class=&quot;hljs-string&quot;&gt;&apos;div&apos;&lt;/span&gt;, &#123;            &lt;span class=&quot;hljs-attr&quot;&gt;style&lt;/span&gt;: &#123;              &lt;span class=&quot;hljs-attr&quot;&gt;background&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;red&apos;&lt;/span&gt;            &#125;          &#125;, &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.$slots.default);        &#125;      &#125;    &#125;,    data () &#123;      &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &#123;        &lt;span class=&quot;hljs-attr&quot;&gt;model&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&apos;abc&apos;&lt;/span&gt;      &#125;    &#125;  &#125;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;jjjjjjjjjjjjjjjjjjjjjj&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;template&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;div&gt;&lt;/div&gt;&lt;p&gt;sadfsfs&lt;/p&gt;&lt;p&gt;大家哦哦好啊谁都发生地方上的冯绍峰s&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;sahhhh&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;compo&gt;&#123;&#123; model &#125;&#125;&lt;/compo&gt;&lt;/p&gt;&lt;pre v-pre=&quot;&quot;&gt;&lt;code v-pre=&quot;&quot; class=&quot;language-html&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;compo&lt;/span&gt;&amp;gt;&lt;/span&gt;&#123;&#123;model &#125;&#125;&#123;&#123;model &#125;&#125;&#123;&#123;model &#125;&#125;&#123;&#123;model &#125;&#125;&#123;&#123; model &#125;&#125;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;compo&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;引入 style 文件&lt;/h2&gt;&lt;div class=&quot;custom&quot;&gt;  原谅色&lt;/div&gt;&lt;/section&gt;&lt;/template&gt;&lt;style src=&quot;./custom.css&quot;&gt;&lt;/style&gt;&lt;style scoped&gt;  .test &#123;    background-color: green;  &#125;&lt;/style&gt;&lt;style scoped&gt;  .abc &#123;    background-color: yellow;  &#125;&lt;/style&gt;&lt;script&gt;  let a=1&lt;2;  let b=&quot;&lt;-forget it-/script&gt;&quot;;  console.log(&quot;***This script tag is successfully extracted and excuted.***&quot;)  module.exports = &#123;    components: &#123;      compo: &#123;        render(h) &#123;          return h(&apos;div&apos;, &#123;            style: &#123;              background: &apos;red&apos;            &#125;          &#125;, this.$slots.default);        &#125;      &#125;    &#125;,    data () &#123;      return &#123;        model: &apos;abc&apos;      &#125;    &#125;  &#125;&lt;/script&gt;&quot;</span><br></pre></td></tr></table></figure>
<p>如果中间哪步不太明白，也可以自行断点调试。总的思路还是很清晰的，就是把 <code>.md</code> 文件通过 <code>markdown-it</code> 转成 <code>html</code>，中间通过选项设置高亮，然后再包裹上 vue 组件的语法形式即可，后续再应用 <code>vue-loader</code> 做后面的处理。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/06/3基于element-ui封装的组件发布npm包/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雯子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Athena">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/06/3基于element-ui封装的组件发布npm包/" itemprop="url">
                  使用Vue CLI 3将基于element-ui二次封装的组件发布到npm
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-06 19:00:19 / 修改时间：19:11:14" itemprop="dateCreated datePublished" datetime="2018-11-06T19:00:19+08:00">2018-11-06</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>首先用<a href="https://cli.vuejs.org/zh/" target="_blank" rel="noopener">Vue CLI 3</a>来初始化项目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn global add @vue/cli</span><br><span class="line">vue create qiyun-el-ui</span><br><span class="line">vue ui</span><br></pre></td></tr></table></figure></p>
<h3 id="安装element-ui"><a href="#安装element-ui" class="headerlink" title="安装element-ui"></a>安装element-ui</h3><p>这里使用官方提供的的插件安装：<br><a href="http://element.eleme.io/#/zh-CN/component/quickstart#shi-yong-vue-cli-at-3" target="_blank" rel="noopener">http://element.eleme.io/#/zh-CN/component/quickstart#shi-yong-vue-cli-at-3</a></p>
<p><a href="https://github.com/ElementUI/vue-cli-plugin-element" target="_blank" rel="noopener">https://github.com/ElementUI/vue-cli-plugin-element</a></p>
<p>在插件列表搜索element<br><img src="https://user-images.githubusercontent.com/10095631/43555082-b9414998-962a-11e8-83ab-cda066a61093.png" alt="image"><br>在这里我选的手动导入，图中是全部导入<br><img src="https://user-images.githubusercontent.com/10095631/43555119-f486f034-962a-11e8-9862-dcaca0e3ebb3.png" alt="image"></p>
<p>这样在项目中，就会新建一个plugins文件夹，里面有个element.js 文件，如果想手动引入，就在这里添加要依赖的组件，这里是为了调试组件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; </span><br><span class="line">  Button, </span><br><span class="line">  Dialog </span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Button)</span><br><span class="line">Vue.use(Dialog)</span><br></pre></td></tr></table></figure></p>
<p>由于我们是基于<code>element-ui</code>的部分组件做的二次封装，所以最好还是按需引入所依赖的组件比较好。</p>
<h2 id="编写组件"><a href="#编写组件" class="headerlink" title="编写组件"></a>编写组件</h2><p>在 <code>src</code> 的同级下面新建 <code>packages</code> 目录，在这里添加自己封装的要发布的组件。<br>例如，新建 <code>qe-modal</code> 文件夹，再接着新建 <code>src</code> 文件夹，里面新建 <code>qe-modal.vue</code>，在这里写组件的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-dialog</span><br><span class="line">    :title=&quot;title&quot;</span><br><span class="line">    :visible=&quot;dialogVisible&quot;</span><br><span class="line">    @close=&quot;$emit(&apos;update:dialogVisible&apos;, false)&quot;</span><br><span class="line">    :width=&quot;width&quot;&gt;</span><br><span class="line">    &lt;slot name=&quot;modal-body&quot;&gt;&lt;/slot&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;</span><br><span class="line">      &lt;slot name=&quot;modal-footer&quot;&gt;</span><br><span class="line">        &lt;el-button @click=&quot;$emit(&apos;update:dialogVisible&apos;, false)&quot; size=&quot;small&quot;&gt;取 消&lt;/el-button&gt;</span><br><span class="line">        &lt;el-button type=&quot;primary&quot; @click=&quot;$emit(&apos;confirm&apos;)&quot; size=&quot;small&quot; :disabled=&quot;confirmDisable || beforeSendDisable&quot;&gt;&#123;&#123; beforeSendDisable? &quot;处理中...&quot; : &quot;确 定&quot; &#125;&#125;&lt;/el-button&gt;</span><br><span class="line">      &lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/el-dialog&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;qeModal&apos;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    dialogVisible: Boolean,</span><br><span class="line">    title: String,</span><br><span class="line">    width: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      default: &apos;580px&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeSendDisable: &#123;</span><br><span class="line">      type: Boolean,</span><br><span class="line">      default: false</span><br><span class="line">    &#125;,</span><br><span class="line">    confirmDisable: &#123;</span><br><span class="line">      type: Boolean,</span><br><span class="line">      default: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>在 <code>qe-modal</code> 根目录下新建 <code>index.js</code> ，里面注册单独的该组件，方便使用时可以单独引用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> qeModal <span class="keyword">from</span> <span class="string">'./src/qe-modal'</span></span><br><span class="line"></span><br><span class="line">qeModal.install = <span class="function"><span class="keyword">function</span>(<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">  Vue.component(qeModal.name, qeModal)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> qeModal</span><br></pre></td></tr></table></figure></p>
<p>这样一个组件就添加完成了，然后需要在 <code>packages</code> 的根目录下添加一个总的 <code>index.js</code>，这里是全局注册的地方，使用时可以全局引入，其实就跟 <code>element-ui</code> 的两种方式一样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> qeModal <span class="keyword">from</span> <span class="string">'./qe-modal'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> components = [</span><br><span class="line">  qeModal</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> install = <span class="function"><span class="keyword">function</span>(<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">  components.forEach(<span class="function"><span class="params">component</span> =&gt;</span> &#123;</span><br><span class="line">    Vue.component(component.name, component);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span> &amp;&amp; <span class="built_in">window</span>.Vue) &#123;</span><br><span class="line">  install(<span class="built_in">window</span>.Vue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  install,</span><br><span class="line">  qeModal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>后面再添加组件，在这里也要再注册一下，而<code>element-ui</code> 源码中是动态引入的，我们的项目组件还没那么多，可以先一个个手动引入，如果后面数量多了，不好维护，可以参考 <code>element-ui</code>  的源码实现，我在<a href="https://athena0304.github.io/element-analysis/build/bin/build-entry.js.html" target="_blank" rel="noopener">这里</a>做了一些简单的解释。</p>
<h2 id="配置-npm"><a href="#配置-npm" class="headerlink" title="配置 npm"></a>配置 npm</h2><p>在 package.json 里面的 script 里面加一个 lib选项，方便每次构建：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="comment">// ...,</span></span><br><span class="line">    <span class="string">"lib"</span>: <span class="string">"vue-cli-service build --target lib --name qiyun-el-ui --dest lib ./packages/index.js"</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p>
<p>其中 <code>--name</code> 后面是你最后想要生成文件的名字，并用 <code>--dest lib</code> 修改了构建的目录。<br>然后在 <code>package.json</code> 里面添加一些npm包发布的相关信息，比如作者、版本等：<br>其中最重要的是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;main&quot;: &quot;lib/qiyun-el-ui.common.js&quot;,</span><br></pre></td></tr></table></figure>
<p>这里的路径要和上面构建出来的目录和文件名对应上。</p>
<p>里面的配置项，在网上找了个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"maucash"</span>,</span><br><span class="line">  <span class="string">"description"</span>: <span class="string">"maucash中常用组件抽取"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.0.2"</span>,</span><br><span class="line">  <span class="string">"author"</span>: <span class="string">"kuangshp &lt;kuangshp@126.com&gt;"</span>,</span><br><span class="line">  <span class="comment">// 开源协议</span></span><br><span class="line">  <span class="string">"license"</span>: <span class="string">"MIT"</span>,</span><br><span class="line">  <span class="comment">// 因为组件包是公用的，所以private为false</span></span><br><span class="line">  <span class="string">"private"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 配置main结点，如果不配置，我们在其他项目中就不用import XX from '包名'来引用了，只能以包名作为起点来指定相对的路径</span></span><br><span class="line">  <span class="string">"main"</span>: <span class="string">"dist/maucash.js"</span>,</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"dev"</span>: <span class="string">"cross-env NODE_ENV=development webpack-dev-server --open --hot"</span>,</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"cross-env NODE_ENV=production webpack --progress --hide-modules"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"axios"</span>: <span class="string">"^0.18.0"</span>,</span><br><span class="line">    <span class="string">"iview"</span>: <span class="string">"^2.14.1"</span>,</span><br><span class="line">    <span class="string">"style-loader"</span>: <span class="string">"^0.23.1"</span>,</span><br><span class="line">    <span class="string">"url-loader"</span>: <span class="string">"^1.1.2"</span>,</span><br><span class="line">    <span class="string">"vue"</span>: <span class="string">"^2.5.11"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 指定代码所在的仓库地址</span></span><br><span class="line">  <span class="string">"repository"</span>: &#123;</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"git"</span>,</span><br><span class="line">    <span class="string">"url"</span>: <span class="string">"git+git@git.wolaidai.com:maucash/maucash.git"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 指定打包后,包中存在的文件夹</span></span><br><span class="line">  <span class="string">"files"</span>: [</span><br><span class="line">    <span class="string">"dist"</span>,</span><br><span class="line">    <span class="string">"src"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// 指定关键词</span></span><br><span class="line">  <span class="string">"keywords"</span>: [</span><br><span class="line">    <span class="string">"vue"</span>,</span><br><span class="line">    <span class="string">"maucash"</span>,</span><br><span class="line">    <span class="string">"code"</span>,</span><br><span class="line">    <span class="string">"maucash code"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// 项目官网的地址</span></span><br><span class="line">  <span class="string">"homepage"</span>: <span class="string">"https://github.com/kuangshp/maucash"</span>,</span><br><span class="line">  <span class="string">"browserslist"</span>: [</span><br><span class="line">    <span class="string">"&gt; 1%"</span>,</span><br><span class="line">    <span class="string">"last 2 versions"</span>,</span><br><span class="line">    <span class="string">"not ie &lt;= 8"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"babel-core"</span>: <span class="string">"^6.26.0"</span>,</span><br><span class="line">    <span class="string">"babel-loader"</span>: <span class="string">"^7.1.2"</span>,</span><br><span class="line">    <span class="string">"babel-plugin-transform-runtime"</span>: <span class="string">"^6.23.0"</span>,</span><br><span class="line">    <span class="string">"babel-preset-env"</span>: <span class="string">"^1.6.0"</span>,</span><br><span class="line">    <span class="string">"babel-preset-stage-3"</span>: <span class="string">"^6.24.1"</span>,</span><br><span class="line">    <span class="string">"cross-env"</span>: <span class="string">"^5.0.5"</span>,</span><br><span class="line">    <span class="string">"css-loader"</span>: <span class="string">"^0.28.7"</span>,</span><br><span class="line">    <span class="string">"file-loader"</span>: <span class="string">"^1.1.4"</span>,</span><br><span class="line">    <span class="string">"node-sass"</span>: <span class="string">"^4.5.3"</span>,</span><br><span class="line">    <span class="string">"sass-loader"</span>: <span class="string">"^6.0.6"</span>,</span><br><span class="line">    <span class="string">"vue-loader"</span>: <span class="string">"^13.0.5"</span>,</span><br><span class="line">    <span class="string">"vue-template-compiler"</span>: <span class="string">"^2.4.4"</span>,</span><br><span class="line">    <span class="string">"webpack"</span>: <span class="string">"^3.6.0"</span>,</span><br><span class="line">    <span class="string">"webpack-dev-server"</span>: <span class="string">"^2.9.1"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="发布到npm"><a href="#发布到npm" class="headerlink" title="发布到npm"></a>发布到npm</h2><p>到这块后面的网上有很多更细致的教程，我就不在这里赘述了。下面给出两个文章的链接，供参考。</p>
<p>1、到<a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm</a>上注册一个账号</p>
<p>2、登录<br><code>npm login</code></p>
<p>3、添加用户信息<br><code>npm adduser</code></p>
<p>4、发布到远程仓库(npm)上<br><code>npm publish</code></p>
<p>5、删除远程仓库的包<br><code>npx force-unpublish package-name &#39;原因描述&#39;</code></p>
<p>参考：<br><a href="https://juejin.im/post/5bc44175f265da0a906f9869" target="_blank" rel="noopener">https://juejin.im/post/5bc44175f265da0a906f9869</a><br><a href="https://www.jb51.net/article/148692.htm" target="_blank" rel="noopener">Vue cli3 库模式搭建组件库并发布到 npm的流程<em>vue.js</em>脚本之家</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/04/newvscreate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雯子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Athena">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/04/newvscreate/" itemprop="url">
                  简单理解一下 Object.create() 与 new 之间的区别
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-04 16:19:51 / 修改时间：16:20:15" itemprop="dateCreated datePublished" datetime="2018-11-04T16:19:51+08:00">2018-11-04</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先看一下 <code>Object.create</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dog = &#123;</span><br><span class="line">    eat: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.eatFood)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> maddie = <span class="built_in">Object</span>.create(dog);</span><br><span class="line"><span class="built_in">console</span>.log(dog.isPrototypeOf(maddie)); <span class="comment">//true</span></span><br><span class="line">maddie.eatFood = <span class="string">'NomNomNom'</span>; </span><br><span class="line">maddie.eat(); <span class="comment">//NomNomNom</span></span><br></pre></td></tr></table></figure>
<p>上面的代码遵循以下步骤：</p>
<ol>
<li>创建一个字面量对象 <code>dog</code>，并且有一个方法 <code>eat</code>。</li>
<li>使用 <code>Object.create(dog)</code> 初始化 <code>maddie</code>，创建了一个全新的对象，并将该对象的原型设置成 <code>dog</code>。</li>
<li>测试 <code>dog</code> 是否是 <code>maddie</code> 的原型。</li>
<li>通过 <code>maddie.eatFood</code> 设置将要输出的变量。</li>
<li>在新创建的 <code>maddie</code> 上调用 <code>eat</code> 方法。</li>
<li>查找原型链，找到 <code>dog</code> 里面的 <code>eat</code> 方法，此时 <code>this</code> 指向的是 <code>maddie</code></li>
<li>控制台输出 <code>NomNomNom</code>。</li>
</ol>
<p>现在再看一下 <code>**new**</code> 操作符：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Dog = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.eatFood = <span class="string">'NomNomNom'</span>;</span><br><span class="line">    <span class="keyword">this</span>.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.eatFood)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> maddie = <span class="keyword">new</span>(Dog);</span><br><span class="line"><span class="built_in">console</span>.log(maddie <span class="keyword">instanceof</span> Dog); <span class="comment">// True</span></span><br><span class="line">maddie.eat(); <span class="comment">//NomNomNom</span></span><br></pre></td></tr></table></figure>
<p>这里遵循以下步骤：</p>
<ol>
<li>创建一个新的对象，<code>maddie</code>。</li>
<li><code>maddie</code> 继承了构造函数的原型。</li>
<li>执行构造函数，将 <code>this</code> 设置成第一步创建的对象。</li>
<li>返回创建的对象（除非构造函数返回了其它对象）。</li>
</ol>
<p>乍一看上去两者都创建了一个新的对象，然后继承了原型，下面这个例子可以看出区别：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.pupper = <span class="string">'Pupper'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Dog.prototype.pupperino = <span class="string">'Pups.'</span>;</span><br><span class="line"><span class="keyword">var</span> maddie = <span class="keyword">new</span> Dog();</span><br><span class="line"><span class="keyword">var</span> buddy = <span class="built_in">Object</span>.create(Dog.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Using Object.create()</span></span><br><span class="line"><span class="built_in">console</span>.log(buddy.pupper); <span class="comment">//Output is undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(buddy.pupperino); <span class="comment">//Output is Pups.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Using New Keyword</span></span><br><span class="line"><span class="built_in">console</span>.log(maddie.pupper); <span class="comment">//Output is Pupper</span></span><br><span class="line"><span class="built_in">console</span>.log(maddie.pupperino); <span class="comment">//Output is Pups.</span></span><br></pre></td></tr></table></figure>
<p>这里有一个关键点就是这句话：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(buddy.pupper); <span class="comment">//Output is undefined</span></span><br></pre></td></tr></table></figure>
<p>这里我们发现 <code>buddy.pupper</code> 输出的是 <code>undefined</code>。即使 <code>Object.create()</code> 将 <code>buddy</code> 的原型设置成了 <code>Dog</code>，但是 <code>buddy</code> 还是无法访问到狗在函数中的 <code>**this.pupper**</code>。这是因为 <code>new Dog</code> 实际上执行了构造函数，而 <code>Object.create</code> 没有执行。</p>
<p>原文：<a href="https://medium.com/@jonathanvox01/understanding-the-difference-between-object-create-and-the-new-operator-b2a2f4749358" target="_blank" rel="noopener">https://medium.com/@jonathanvox01/understanding-the-difference-between-object-create-and-the-new-operator-b2a2f4749358</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/04/understanding-design-patterns-in-javascript/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雯子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Athena">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/04/understanding-design-patterns-in-javascript/" itemprop="url">
                  【译】简单理解 JavaScript 中的设计模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-04 16:14:02 / 修改时间：16:19:31" itemprop="dateCreated datePublished" datetime="2018-11-04T16:14:02+08:00">2018-11-04</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>当你开始一个新的项目时，一般不会立即开始编码，首先必须要定义项目的目的和范围，然后列出项目的特性或规格。在可以开始编写代码之后，或者如果你正在处理一个更复杂的项目，那么你应该选择一个最适合该项目的设计模式。</p>
<h2 id="什么是设计模式？"><a href="#什么是设计模式？" class="headerlink" title="什么是设计模式？"></a>什么是设计模式？</h2><p>在软件工程中，设计模式是软件设计中常见问题的可重用解决方案。设计模式代表了经验丰富的软件开发人员所使用的最佳实践。设计模式可以看作是编程模板。</p>
<h3 id="为什么要使用设计模式？"><a href="#为什么要使用设计模式？" class="headerlink" title="为什么要使用设计模式？"></a>为什么要使用设计模式？</h3><p>很多程序员要么认为设计模式浪费时间，要么不知道如何恰当地应用它们。但是使用适当的设计模式可以帮助你编写更好、更易于理解的代码，且更容易维护。</p>
<p>最重要的是，设计模式为软件开发人员提供了一个可以讨论的通用词汇表。它们会立即向学习代码的人显示代码的意图。</p>
<p>例如，如果你在项目中使用装饰者模式，那么新加入的开发人员将立即知道这段代码在做什么，所以他们可以更关注于解决业务问题，而不是试图理解代码在做什么。</p>
<p>现在我们已经知道了什么是设计模式，以及它们为什么重要，接下来让我们深入研究 JavaScript 中使用的各种设计模式。</p>
<h2 id="模块模式-Module-Pattern"><a href="#模块模式-Module-Pattern" class="headerlink" title="模块模式-Module Pattern"></a>模块模式-Module Pattern</h2><p>模块是一段自包含的代码，因此我们可以在不影响代码其他部分的情况下更新模块。模块还允许我们通过为变量创建单独的作用域来避免命名空间污染。当模块与其他代码片段分离时，我们还可以在其他项目中重用它们。</p>
<p>模块是任何现代 JavaScript 应用程序的组成部分，它有助于保持代码的整洁、分离和组织。用 JavaScript 创建模块有很多方法，模块模式是其中之一。</p>
<p>与其他编程语言不同，JavaScript没有访问修饰符，也就是说，不能将变量声明为私有或公共。因此，模块模式也被用来模拟封装的概念。</p>
<p>模块模式使用IIFE(立即调用的函数表达式)、闭包和函数作用域来模拟此概念。例如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myModule = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> privateVariable = <span class="string">'Hello World'</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateMethod</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(privateVariable);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    publicMethod: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      privateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">myModule.publicMethod();</span><br></pre></td></tr></table></figure>
<p>由于它是 IIFE，代码立即被执行，返回的对象被分配给 <code>myModule</code> 变量。因为闭包，所以返回的对象仍然可以访问在IIFE中定义的函数和变量，即使在 IIFE 结束之后。</p>
<p>在 IIFE 中定义的变量和函数在外部作用域是不可见的，于是它们成为了 <code>myModule</code> 的私有变量。</p>
<p>代码执行过后，<code>myModule</code> 变量看上去是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myModule = &#123;</span><br><span class="line">  publicMethod: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    privateMethod();</span><br><span class="line">  &#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>因此，我们可以调用 <code>publicMethod()</code>，然后依次调用 <code>privateMethod()</code>。例如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Prints 'Hello World'</span></span><br><span class="line"><span class="built_in">module</span>.publicMethod();</span><br></pre></td></tr></table></figure>
<h2 id="揭示模块模式-Revealing-Module-Pattern"><a href="#揭示模块模式-Revealing-Module-Pattern" class="headerlink" title="揭示模块模式-Revealing Module Pattern"></a>揭示模块模式-Revealing Module Pattern</h2><p>揭示模块模式是由 Christian Heilmann 基于模块模式略微改进的版本。模块模式的问题是，我们必须创建新的公共函数，仅仅是用来调用私有函数和变量。</p>
<p>在这个模式中，我们将返回对象的属性映射到我们想要公开的私有函数。这就是为什么它被称为揭示模块模式。例如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myRevealingModule = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> privateVar = <span class="string">'Peter'</span>;</span><br><span class="line">  <span class="keyword">const</span> publicVar  = <span class="string">'Hello World'</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Name: '</span>+ privateVar);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">publicSetName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    privateVar = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">publicGetName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    privateFunction();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/** reveal methods and variables by assigning them to object properties */</span></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    setName: publicSetName,</span><br><span class="line">    greeting: publicVar,</span><br><span class="line">    getName: publicGetName</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line">myRevealingModule.setName(<span class="string">'Mark'</span>);</span><br><span class="line"><span class="comment">// prints Name: Mark</span></span><br><span class="line">myRevealingModule.getName();</span><br></pre></td></tr></table></figure>
<p>这种模式使我们更容易理解哪些函数和变量可以公开访问，有助于代码的可读性。</p>
<p>执行代码之后，<code>myRevealingModule</code> 如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myRevealingModule = &#123;</span><br><span class="line">  setName: publicSetName,</span><br><span class="line">  greeting: publicVar,</span><br><span class="line">  getName: publicGetName</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以调用 <code>myRevealingModule.setName(&#39;Mark&#39;)</code>，它是对内部 <code>publicSetName</code> 的引用，还可以调用 <code>myRevealingModule.getName()</code> ，是对内部 <code>publicGetName</code> 的引用。例如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myRevealingModule.setName(<span class="string">'Mark'</span>);</span><br><span class="line"><span class="comment">// prints Name: Mark</span></span><br><span class="line">myRevealingModule.getName();</span><br></pre></td></tr></table></figure>
<h3 id="揭示模块模式相比模块模式的优势："><a href="#揭示模块模式相比模块模式的优势：" class="headerlink" title="揭示模块模式相比模块模式的优势："></a>揭示模块模式相比模块模式的优势：</h3><ul>
<li>通过修改 return 语句中的一行代码，我们可以将成员从 public 更改为 private，反之亦然。</li>
<li>返回的对象不包含任何函数定义，所有右侧表达式都在IIFE中定义，使代码清晰且易于阅读。</li>
</ul>
<h2 id="ES6模块-ES6-Modules"><a href="#ES6模块-ES6-Modules" class="headerlink" title="ES6模块-ES6 Modules"></a>ES6模块-ES6 Modules</h2><p>在 ES6 之前，JavaScript 没有内置模块，因此开发人员不得不依赖第三方库或模块模式来实现模块。但是在 ES6中，JavaScript 有原生模块。</p>
<p>ES6模块存储在文件中。每个文件只能有一个模块。默认情况下，模块中的所有内容都是私有的。使用 <code>export</code> 关键字公开函数、变量和类。模块内的代码总是在严格模式下运行。</p>
<h3 id="导出模块"><a href="#导出模块" class="headerlink" title="导出模块"></a>导出模块</h3><p>导出函数和变量声明有两种方法：</p>
<ul>
<li>通过在函数和变量声明前添加 <code>export</code> 关键字。例如：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utils.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> greeting = <span class="string">'Hello World'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Sum:'</span>, num1, num2);</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">subtract</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Subtract:'</span>, num1, num2);</span><br><span class="line">  <span class="keyword">return</span> num1 - num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// This is a private function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">privateLog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Private Function'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过在包含要导出的函数和变量名称的代码末尾添加 <code>export</code> 关键字。例如：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utils.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Multiply:'</span>, num1, num2);</span><br><span class="line">  <span class="keyword">return</span> num1 * num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">divide</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Divide:'</span>, num1, num2);</span><br><span class="line">  <span class="keyword">return</span> num1 / num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// This is a private function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">privateLog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Private Function'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;multiply, divide&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h3><p>与导出模块类似，有两种方法可以使用 <code>import</code> 关键字导入模块。例如：</p>
<ul>
<li>一次导入多个项</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="comment">// importing multiple items</span></span><br><span class="line"><span class="keyword">import</span> &#123; sum, multiply &#125; <span class="keyword">from</span> <span class="string">'./utils.js'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">3</span>, <span class="number">7</span>));</span><br><span class="line"><span class="built_in">console</span>.log(multiply(<span class="number">3</span>, <span class="number">7</span>));</span><br></pre></td></tr></table></figure>
<ul>
<li>导入所有内容</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="comment">// importing all of module</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> utils <span class="keyword">from</span> <span class="string">'./utils.js'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(utils.sum(<span class="number">3</span>, <span class="number">7</span>));</span><br><span class="line"><span class="built_in">console</span>.log(utils.multiply(<span class="number">3</span>, <span class="number">7</span>));</span><br></pre></td></tr></table></figure>
<h3 id="导入和导出可以重命名"><a href="#导入和导出可以重命名" class="headerlink" title="导入和导出可以重命名"></a>导入和导出可以重命名</h3><p>如果希望避免命名冲突，可以在导入和导出时修改命名，例如：</p>
<ul>
<li>重命名导出</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utils.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Sum:'</span>, num1, num2);</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Multiply:'</span>, num1, num2);</span><br><span class="line">  <span class="keyword">return</span> num1 * num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;sum <span class="keyword">as</span> add, multiply&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>重命名导入</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; add, multiply <span class="keyword">as</span> mult &#125; <span class="keyword">from</span> <span class="string">'./utils.js'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">3</span>, <span class="number">7</span>));</span><br><span class="line"><span class="built_in">console</span>.log(mult(<span class="number">3</span>, <span class="number">7</span>));</span><br></pre></td></tr></table></figure>
<h2 id="单例模式-Singleton-Pattern"><a href="#单例模式-Singleton-Pattern" class="headerlink" title="单例模式-Singleton Pattern"></a>单例模式-Singleton Pattern</h2><p>单例对象是只能实例化一次的对象。如果一个类不存在，单例模式会创建一个新的类实例。如果实例存在，它只返回对该对象的引用。对构造函数的任何重复调用都将获取相同的对象。</p>
<p>在 JavaScript 中，一直都有内置的单例。我们只是不称它们为单例，而是对象字面量（object literal）。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  name: <span class="string">'Peter'</span>,</span><br><span class="line">  age: <span class="number">25</span>,</span><br><span class="line">  job: <span class="string">'Teacher'</span>,</span><br><span class="line">  greet: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为 JavaScript 中的每个对象都占用一个唯一的内存位置，当我们调用 <code>user</code> 对象时，实际上是返回对这个对象的引用。</p>
<p>如果我们试图将 <code>user</code> 变量复制到另一个变量中并修改该变量。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user1 = user;</span><br><span class="line">user1.name = <span class="string">'Mark'</span>;</span><br></pre></td></tr></table></figure>
<p>我们会看到两个对象都被修改了，因为 JavaScript 中的对象是通过引用而不是值传递的。所以内存中只有一个对象。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// prints 'Mark'</span></span><br><span class="line"><span class="built_in">console</span>.log(user.name);</span><br><span class="line"><span class="comment">// prints 'Mark'</span></span><br><span class="line"><span class="built_in">console</span>.log(user1.name);</span><br><span class="line"><span class="comment">// prints true</span></span><br><span class="line"><span class="built_in">console</span>.log(user === user1);</span><br></pre></td></tr></table></figure>
<p>单例模式可以使用构造函数实现。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> instance = <span class="literal">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(instance) &#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">  instance = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'Peter'</span>;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">25</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> user1 = <span class="keyword">new</span> User();</span><br><span class="line"><span class="keyword">const</span> user2 = <span class="keyword">new</span> User();</span><br><span class="line"><span class="comment">// prints true</span></span><br><span class="line"><span class="built_in">console</span>.log(user1 === user2);</span><br></pre></td></tr></table></figure>
<p>当调用这个构造函数时，检查 <code>instance</code> 对象是否存在。如果对象不存在，则将 <code>this</code> 变量赋给 <code>instance</code> 变量。如果对象存在，则只返回那个对象。</p>
<p>单例模式也可以使用模块模式来实现。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> singleton = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      name: <span class="string">'Peter'</span>,</span><br><span class="line">      age: <span class="number">24</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getInstance: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(!instance) &#123;</span><br><span class="line">        instance = init();</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">const</span> instanceA = singleton.getInstance();</span><br><span class="line"><span class="keyword">const</span> instanceB = singleton.getInstance();</span><br><span class="line"><span class="comment">// prints true</span></span><br><span class="line"><span class="built_in">console</span>.log(instanceA === instanceB);</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们通过调用 <code>singleton.getInstance</code> 方法来创建一个新的实例。如果实例已经存在，此方法只返回该实例，如果实例不存在，则通过调用 <code>init()</code> 函数创建新实例。</p>
<h2 id="工厂模式-Factory-Pattern"><a href="#工厂模式-Factory-Pattern" class="headerlink" title="工厂模式-Factory Pattern"></a>工厂模式-Factory Pattern</h2><p>工厂模式使用工厂方法创建对象，而不指定创建对象的确切类或构造函数。</p>
<p>工厂模式用于创建对象，而不公开实例化逻辑。当我们需要根据特定条件生成不同的对象时，可以使用此模式。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">this</span>.doors = options.doors || <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">this</span>.state = options.state || <span class="string">'brand new'</span>;</span><br><span class="line">    <span class="keyword">this</span>.color = options.color || <span class="string">'white'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Truck</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">this</span>.doors = options.doors || <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">this</span>.state = options.state || <span class="string">'used'</span>;</span><br><span class="line">    <span class="keyword">this</span>.color = options.color || <span class="string">'black'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VehicleFactory</span> </span>&#123;</span><br><span class="line">  createVehicle(options) &#123;</span><br><span class="line">    <span class="keyword">if</span>(options.vehicleType === <span class="string">'car'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Car(options);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(options.vehicleType === <span class="string">'truck'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Truck(options);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我创建了一个 <code>Car</code> 和一个 <code>Truck</code> 类（带有一些默认值），用于创建新的 <code>car</code> 和 <code>truck</code> 对象。我还定义了一个 <code>VehicleFactory</code> 类，它根据 <code>options</code> 对象中接收到的 <code>vehicleType</code> 属性创建并返回一个新的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> factory = <span class="keyword">new</span> VehicleFactory();</span><br><span class="line"><span class="keyword">const</span> car = factory.createVehicle(&#123;</span><br><span class="line">  vehicleType: <span class="string">'car'</span>,</span><br><span class="line">  doors: <span class="number">4</span>,</span><br><span class="line">  color: <span class="string">'silver'</span>,</span><br><span class="line">  state: <span class="string">'Brand New'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> truck= factory.createVehicle(&#123;</span><br><span class="line">  vehicleType: <span class="string">'truck'</span>,</span><br><span class="line">  doors: <span class="number">2</span>,</span><br><span class="line">  color: <span class="string">'white'</span>,</span><br><span class="line">  state: <span class="string">'used'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Prints Car &#123;doors: 4, state: "Brand New", color: "silver"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(car);</span><br><span class="line"><span class="comment">// Prints Truck &#123;doors: 2, state: "used", color: "white"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(truck);</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们基于 <code>VehicleFactory</code> 类创建了一个新的对象 <code>factory</code>。然后通过调用 <code>factory.createVehicle</code>，传入带有 <code>vehicleType</code> 属性的 <code>options</code> 对象参数，创建了新的 <code>car</code> 和 <code>truck</code> 对象。</p>
<h2 id="装饰者模式-Decorator-Pattern"><a href="#装饰者模式-Decorator-Pattern" class="headerlink" title="装饰者模式-Decorator Pattern"></a>装饰者模式-Decorator Pattern</h2><p>装饰者模式用于扩展对象的功能，而无需修改现有的类或构造函数。此模式可用于向对象添加特性，而无需修改底层代码。</p>
<p>一个简单的例子如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="comment">// Default values</span></span><br><span class="line">  <span class="keyword">this</span>.color = <span class="string">'White'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Creating a new Object to decorate</span></span><br><span class="line"><span class="keyword">const</span> tesla= <span class="keyword">new</span> Car(<span class="string">'Tesla Model 3'</span>);</span><br><span class="line"><span class="comment">// Decorating the object with new functionality</span></span><br><span class="line">tesla.setColor = <span class="function"><span class="keyword">function</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line">tesla.setPrice = <span class="function"><span class="keyword">function</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line">tesla.setColor(<span class="string">'black'</span>);</span><br><span class="line">tesla.setPrice(<span class="number">49000</span>);</span><br><span class="line"><span class="comment">// prints black</span></span><br><span class="line"><span class="built_in">console</span>.log(tesla.color);</span><br></pre></td></tr></table></figure>
<p>这种模式的一个更实际的例子是：</p>
<p>比方说，一辆车的价格取决于它有多少功能。如果没有装饰者模式，我们将不得不为不同的特性组合创建不同的类，每个类都有计算成本的方法。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>() </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarWithAC</span>() </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarWithAutoTransmission</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarWithPowerLocks</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarWithACandPowerLocks</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是使用装饰者模式，我们可以创建一个基类 <code>Car</code>，并使用装饰函数向其对象添加不同配置的成本。例如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">  <span class="comment">// Default Cost</span></span><br><span class="line">  <span class="keyword">this</span>.cost = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">20000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Decorator function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">carWithAC</span>(<span class="params">car</span>) </span>&#123;</span><br><span class="line">  car.hasAC = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">const</span> prevCost = car.cost();</span><br><span class="line">  car.cost = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prevCost + <span class="number">500</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Decorator function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">carWithAutoTransmission</span>(<span class="params">car</span>) </span>&#123;</span><br><span class="line">  car.hasAutoTransmission = <span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">const</span> prevCost = car.cost();</span><br><span class="line">  car.cost = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prevCost + <span class="number">2000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Decorator function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">carWithPowerLocks</span>(<span class="params">car</span>) </span>&#123;</span><br><span class="line">  car.hasPowerLocks = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">const</span> prevCost = car.cost();</span><br><span class="line">  car.cost = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prevCost + <span class="number">500</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，我们创建一个基类 <code>Car</code> 用来创建 <code>car</code> 对象。然后，为要添加的特性创建装饰器，并将 <code>Car</code> 对象作为参数传递。然后，我们重写该对象的 <code>cost</code> 函数，该函数返回 <code>car</code> 更新后的成本，并向该对象添加一个新属性，用来表明添加了哪些特性。</p>
<p>要添加新特性，我们可以这样做：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> car = <span class="keyword">new</span> Car();</span><br><span class="line"><span class="built_in">console</span>.log(car.cost());</span><br><span class="line">carWithAC(car);</span><br><span class="line">carWithAutoTransmission(car);</span><br><span class="line">carWithPowerLocks(car);</span><br></pre></td></tr></table></figure>
<p>最后，我们可以这样计算汽车的成本：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Calculating total cost of the car</span></span><br><span class="line"><span class="built_in">console</span>.log(car.cost());</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们已经了解了 JavaScript 中使用的各种设计模式，但是还有一些设计模式没有在这里介绍，它们可以在JavaScript 中实现。</p>
<p>虽然了解各种设计模式很重要，但同样重要的是不要过度使用它们。在使用设计模式之前，你应该仔细考虑你的问题是否符合设计模式。要想知道某个模式是否适合你的问题，请了解该模式解决了哪些问题，并检查你是否实际面临类似的问题。</p>
<p>原文：<a href="https://blog.bitsrc.io/understanding-design-patterns-in-javascript-13345223f2dd" target="_blank" rel="noopener">https://blog.bitsrc.io/understanding-design-patterns-in-javascript-13345223f2dd</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/04/examples/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雯子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Athena">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/04/examples/" itemprop="url">
                  【译】通过例子解释 Debounce 和 Throttle
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-04 16:11:09 / 修改时间：16:13:03" itemprop="dateCreated datePublished" datetime="2018-11-04T16:11:09+08:00">2018-11-04</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>Debounce</strong> 和 <strong>Throttle</strong> 是两个很相似但是又不同的技术，都可以控制一个函数在一段时间内执行的次数。</p>
<p>当我们在操作 DOM 事件的时候，为函数添加 debounce 或者 throttle 就会尤为有用。为什么？因为我们在事件和函数执行之间加了一个我们自己的控制层。记住，我们是不去控制这些 DOM 事件触发的频率的，因为这个可能会有变化。</p>
<p>下面我们以滚动事件举例：</p>
<iframe height="265" scrolling="no" title="Scroll events counter" src="//codepen.io/athena0304/embed/Yjbqar/?height=265&theme-id=0&default-tab=css,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/athena0304/pen/Yjbqar/" target="_blank" rel="noopener">Scroll events counter</a> by Athena (<a href="https://codepen.io/athena0304" target="_blank" rel="noopener">@athena0304</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<p>当使用触控板、鼠标滚轮，或者直接拽动滚动条，每秒都可以轻易触发至少30次事件，而且在触屏的移动端，甚至会达到每秒100次，面对这样高的执行频率，你的滚动事件处理程序能否很好地应对？</p>
<p>在2011年，Twitter 网站提出了一个 issue：当向下滚动 Twitter 信息流的时候，整个页面的响应速度都会变慢。 John Resig 基于该问题发表了一篇<a href="http://ejohn.org/blog/learning-from-twitter" target="_blank" rel="noopener">博客</a>，文中指出，直接在 <code>scroll</code> 事件里挂载一些计算量大的函数是件多么不明智的行为。</p>
<p>John 当时提出的解决方案是在 <code>onScroll event</code> 的外部设置一个每 250ms 执行一次的循环。这样处理程序就与事件解耦了。使用这样一个简单的技术就可以避免破坏用户体验。</p>
<p>::: tip 译者注</p>
<p>文中的核心代码如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outerPane = $details.find(<span class="string">".details-pane-outer"</span>),</span><br><span class="line">    didScroll = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">$(<span class="built_in">window</span>).scroll(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    didScroll = <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( didScroll ) &#123;</span><br><span class="line">        didScroll = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// Check your page position and then</span></span><br><span class="line">        <span class="comment">// Load in more results</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">250</span>);</span><br></pre></td></tr></table></figure>
<p>:::</p>
<p>如今，处理事件的方式稍微复杂了一些。下面我们结合用例，一一介绍 Debounce、 Throttle 和requestAnimationFrame。</p>
<h3 id="Debounce"><a href="#Debounce" class="headerlink" title="Debounce"></a>Debounce</h3><p>Debounce 允许我们将多个连续的调用合并成一个。</p>
<p><img src="https://css-tricks.com/wp-content/uploads/2016/04/debounce.png" alt="img"></p>
<p>想象一个进电梯的场景，你走进了电梯，门刚要关上，这时另一个人想要进来，于是电梯没有移动楼层（处理函数），而是将门打开让那个人进来。这时又有一个人要进来，就又会上演刚才那一幕。也就是说，电梯延迟了它的函数（移动楼层）执行，但是优化了资源。</p>
<p>在下面的例子中，尝试快速点击按钮或者在上面滑动：</p>
<iframe height="265" scrolling="no" title="Debounce. Trailing" src="//codepen.io/athena0304/embed/NBVjRB/?height=265&theme-id=0&default-tab=css,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/athena0304/pen/NBVjRB/" target="_blank" rel="noopener">Debounce. Trailing</a> by Athena (<a href="https://codepen.io/athena0304" target="_blank" rel="noopener">@athena0304</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<p>你可以看到连续快速事件是怎样被一个单独的 debounce 事件所替代的。但是如果事件触发时间间隔较长，就不会发生 debounce。</p>
<h4 id="Leading-边缘-或者-“immediate”"><a href="#Leading-边缘-或者-“immediate”" class="headerlink" title="Leading 边缘 (或者 “immediate”)"></a>Leading 边缘 (或者 “immediate”)</h4><p>在上面的例子中，你会发现 debounce 事件会等到快速事件停止发生后才会触发函数执行。为什么不在每次一开始就立即触发函数执行呢，这样它的表现就和原始的没有去抖的处理器一样了。直到快速调用出现停顿的时候，才会再次触发。</p>
<p>下面是使用 <code>leading</code> 标识符的例子：</p>
<p><img src="https://css-tricks.com/wp-content/uploads/2016/04/debounce-leading.png" alt="img"></p>
<p>在 underscore.js 中，该选项叫作 <code>immediate</code> ，而不是  <code>leading</code>。</p>
<p>自己试一下：</p>
<iframe height="265" scrolling="no" title="Debounce. Leading" src="//codepen.io/athena0304/embed/mGbgGo/?height=265&theme-id=0&default-tab=css,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/athena0304/pen/mGbgGo/" target="_blank" rel="noopener">Debounce. Leading</a> by Athena (<a href="https://codepen.io/athena0304" target="_blank" rel="noopener">@athena0304</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>



<h4 id="Debounce-的实现"><a href="#Debounce-的实现" class="headerlink" title="Debounce 的实现"></a>Debounce 的实现</h4><p>Debounce 的概念和实现最早是由 <a href="http://unscriptable.com/2009/03/20/debouncing-javascript-methods/" target="_blank" rel="noopener">John Hann</a> 在2009年提出来的。</p>
<p>不久之后，Ben Alman 就写了一个 <a href="http://benalman.com/projects/jquery-throttle-debounce-plugin/" target="_blank" rel="noopener">jQuery 插件</a>（现在已经不再维护了），一年之后 Jeremy Ashkenas 把它添加进了 underscore.js。再后来被添加进 Lodash。</p>
<p>这三个实现在内部有一点不同，但是接口几乎是相同的。</p>
<p>曾经有一段时间，underscore 采取了 Lodash 里面的 debounce/throttle 实现，但是后来我在2013年发现了  <code>_.debounce</code> 函数的一个 bug。从那时起，这两种实现就出现分化了。</p>
<p>Lodash 为  <code>_.debounce</code> 和 <code>_.throttle</code>  添加了更多的特性。最初的  <code>immediate</code> 标识符被 <code>leading</code> 和 <code>trailing</code>所替代。你可以选择一个选项，也可以两个都要。默认情况下 <code>trailing</code> 是被开启的。</p>
<p>新的  <code>maxWait</code> 选项（目前只存在于Lodash）在本文中没有提及，但是它也是一个很有用的选项。实际上，throttle 函数就是使用  <code>_.debounce</code> 带着 <code>maxWait</code> 的选项来定义的，你可以在这里查看<a href="https://github.com/lodash/lodash/blob/4.8.0-npm/throttle.js" target="_blank" rel="noopener">源码</a>。</p>
<h4 id="Debounce-举例"><a href="#Debounce-举例" class="headerlink" title="Debounce 举例"></a>Debounce 举例</h4><h5 id="Resize-举例"><a href="#Resize-举例" class="headerlink" title="Resize 举例"></a>Resize 举例</h5><p>通过拖拽浏览器窗口，可以触发很多次 <code>resize</code> 事件。</p>
<p>例子如下：</p>
<iframe height="265" scrolling="no" title="Debounce Resize Event Example" src="//codepen.io/athena0304/embed/KxPLZy/?height=265&theme-id=0&default-tab=js,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/athena0304/pen/KxPLZy/" target="_blank" rel="noopener">Debounce Resize Event Example</a> by Athena (<a href="https://codepen.io/athena0304" target="_blank" rel="noopener">@athena0304</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe><br>可以看到，我们在 resize 事件上使用的是默认的  <code>trailing</code> 选项，因为我们只需要关心用户停止调整浏览器后的最终结果就可以了。<br><br>##### 敲击键盘，通过 Ajax 请求自动填充表单<br><br>为什么要在用户还在输入的时候每隔 50ms 就发送一次 Ajax请求？<code>_.debounce</code> 可以帮助我们避免额外的开销，只有当用户停止输入了再发送请求。<br><br>这里没有必要设置  <code>leading</code>，我们是想要等到最后一个字符输入完再执行函数的。<br><br><iframe height="265" scrolling="no" title="Debouncing keystrokes Example" src="//codepen.io/athena0304/embed/NLKVZw/?height=265&theme-id=0&default-tab=js,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/athena0304/pen/NLKVZw/" target="_blank" rel="noopener">Debouncing keystrokes Example</a> by Athena (<a href="https://codepen.io/athena0304" target="_blank" rel="noopener">@athena0304</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe><br>还有一个类似的使用场景就是表单校验，当用户输入完再进行校验、提示信息等。<br><br>#### 如何使用 debounce 和 throttle，以及常见问题<br><br>说了这么多，你可能已经想自己来写 debounce/throttle 函数了，或者是从网上随便一篇博客上拷贝一份下来。<strong>但是我给你的建议是直接使用 underscore 或者 Lodash。</strong> 如果你只是需要 <code>_.debounce</code> 和 <code>_.throttle</code> 函数，可以使用 <a href="https://lodash.com/custom-builds" target="_blank" rel="noopener">Lodash custom builder</a> 来输出一个自定义的压缩后为 2KB 的库。可以使用下列命令来进行构建：<br><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i -g lodash-cli</span><br><span class="line">lodash include = debounce, throttle</span><br></pre></td></tr></table></figure><br><br>也就是说，最好是使用模块化的形式，通过 webpack/browserify/rollup 来引用，如 <code>lodash/throttle</code> 和 <code>lodash/debounce</code> 或 <code>lodash.throttle</code> 和 <code>lodash.debounce</code> 。<br><br>使用 <code>_.debounce</code> 函数的一个常见错误就是多次调用它：<br><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line">$(<span class="built_in">window</span>).on(<span class="string">'scroll'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   _.debounce(doSomething, <span class="number">300</span>); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line">$(<span class="built_in">window</span>).on(<span class="string">'scroll'</span>, _.debounce(doSomething, <span class="number">200</span>));</span><br></pre></td></tr></table></figure><br><br>为 debounced 函数创建一个变量可以让我们调用私有函数 <code>debounced_version.cancel()</code>，如果有需要，lodash 和 underscore.js 都可以供你使用。<br><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> debounced_version = _.debounce(doSomething, <span class="number">200</span>);</span><br><span class="line">$(<span class="built_in">window</span>).on(<span class="string">'scroll'</span>, debounced_version);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果你需要的话</span></span><br><span class="line">debounced_version.cancel();</span><br></pre></td></tr></table></figure><br><br>### Throttle<br><br>使用 <code>_.throttle</code> 则不允许函数每 X 毫秒的执行次数超过一次。<br><br>Throttle 和 debounce 最主要的区别就是 throttle 保证函数每 X 毫秒至少执行一次。<br><br>和 debounce 一样， throttle 也用在了 Ben 的插件、underscore.js 和 lodash里面。<br><br>#### Throttling 举例<br><br>##### 无限滚动<br><br>这是一个非常常见的例子。用户在一个无限滚动的页面里向下滚动，你需要知道当前滚动的位置距离底部还有多远，如果接近底部了，我们就得通过 Ajax 请求获取更多的内容，将其添加到页面里。<br><br>此时我们之前的 <code>_.debounce</code> 就派不上作用了。使用 debounce 只有当用户停止滚动时才能触发，而我们需要的是在用户滚动到底部之前就开始获取内容。<br><br>使用 <code>_.throttle</code> 就能确保实时检查距离底部还有多远。<br><br>### requestAnimationFrame (rAF)<br><br><code>requestAnimationFrame</code> 是另一种限制函数执行速度的方法。<br><br>它可以被看做 <code>_.throttle(dosomething, 16)</code>。但它有着更高的保真度，因为它是浏览器的原生 API，有着更好的精度。<br><br>我们可以使用 rAF API，作为 throttle 函数的替代，考虑下面的优缺点：<br><br>#### 优点<br><br>- 目标是 60fps（每帧 16ms），但是会在浏览器内部决定如何安排渲染的最佳时机。<br>- 非常简单，而且是标准 API，在未来也不会改变。更少的维护成本。<br><br>#### 缺点<br><br>- rAFs 的开始/取消由我们自己来管理，而不像  <code>.debounce</code> 和 <code>.throttle</code> 是在内部管理的。<br>- 如果浏览器的 tab 页面不活跃了，它就不会再执行。<br>- 虽然所有的现代浏览器都提供了 rAF， 但是 IE9、Opera Mini 和一些老的安卓版本还不支持。如果需要，现在还是要使用 <a href="http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/" target="_blank" rel="noopener">polyfill</a> 。<br>- Node.js 不支持 rAF，所以不能在服务端用于 throttle 文件系统事件。<br><br>根据经验，如果你的 JavaScript 函数是在绘制或者直接改变属性，所有涉及到元素位置重新计算的，我会建议使用  <code>requestAnimationFrame</code>，<br><br>如果是处理 Ajax 请求，或者决定是否添加/删除某个 class（可能会触发一个 CSS 动画），我会考虑 <code>_.debounce</code> 和 <code>_.throttle</code>，这里可以设置更低一些的执行速度（例如 200ms，而不是16ms）。<br><br>这时你可能会想，为什不把 rAF 集成到 underscore 或 lodash 里呢，那他俩都是拒绝的，因为这只是一个特殊的使用场景，而且已经足够简单，可以被直接调用。<br><br>#### rAF 举例<br><br>受<a href="http://www.html5rocks.com/en/tutorials/speed/animations/" target="_blank" rel="noopener">这篇文章</a>的启发，在这里我会举一个滚动的例子，在这篇文章中有每个步骤的逻辑解释。<br><br>我做了一个对比实验，一边是 rAF，一边是 16ms 间隔的 <code>_.throttle</code>。它们性能很相似，但是 rAF 可能会在更复杂的场景下性能更高一些。<br><br><iframe height="265" scrolling="no" title="Scroll comparison requestAnimationFrame vs throttle" src="//codepen.io/dcorb/embed/pgOKKw/?height=265&theme-id=0&default-tab=js,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/dcorb/pen/pgOKKw/" target="_blank" rel="noopener">Scroll comparison requestAnimationFrame vs throttle</a> by Corbacho (<a href="https://codepen.io/dcorb" target="_blank" rel="noopener">@dcorb</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<p>还有一个更高级的例子，在 headroom.js 中，逻辑被<a href="https://github.com/WickyNilliams/headroom.js/blob/3282c23bc69b14f21bfbaf66704fa37b58e3241d/src/Debouncer.js" target="_blank" rel="noopener">解耦</a>了，并且包裹在了对象中。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用 debounce、throttle 和  <code>requestAnimationFrame</code>  来优化你的事件处理程序。每种技术都有些许的不同，但是三个都是很有用的，而且能够互补。</p>
<p>总结：</p>
<ul>
<li><strong>debounce</strong>：将一系列迅速触发的事件（例如敲击键盘）合并成一个单独的事件。</li>
<li><strong>throttle</strong>：确保一个持续的操作流以每 X 毫秒执行一次的速度执行。例如每 200ms 检查一下滚动条的位置来触发某个 CSS 动画。</li>
<li><strong>requestAnimationFrame</strong>：throttle的一个替代品。适用于需要计算元素在屏幕上的位置和渲染的时候，能够保证动画或者变化的平滑性。注意：IE9 不支持。</li>
</ul>
<p>原文链接：<a href="https://css-tricks.com/debouncing-throttling-explained-examples/" target="_blank" rel="noopener">https://css-tricks.com/debouncing-throttling-explained-examples/</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/03/词法环境/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雯子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Athena">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/03/词法环境/" itemprop="url">
                  词法环境
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-03 19:43:19" itemprop="dateCreated datePublished" datetime="2018-11-03T19:43:19+08:00">2018-11-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-11-09 13:12:55" itemprop="dateModified" datetime="2018-11-09T13:12:55+08:00">2018-11-09</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="8-可执行代码和执行上下文"><a href="#8-可执行代码和执行上下文" class="headerlink" title="8 可执行代码和执行上下文"></a>8 可执行代码和执行上下文</h3><h3 id="8-1-词法环境"><a href="#8-1-词法环境" class="headerlink" title="8.1 词法环境"></a>8.1 词法环境</h3><p>词法环境是一种规范类型，用于根据ECMAScript代码的词法嵌套结构定义标识符与特定变量和函数的关联。词法环境由环境记录和对外部词法环境的引用（可能为null）组成。通常，词法环境与ECMAScript代码的特定语法结构相关联，例如FunctionDeclaration、BlockStatement或Try Catch语句，每次计算这些代码时都会创建一个新的词法环境。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/01/事件顺序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雯子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Athena">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/01/事件顺序/" itemprop="url">
                  事件顺序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-01 11:32:50 / 修改时间：11:34:12" itemprop="dateCreated datePublished" datetime="2018-11-01T11:32:50+08:00">2018-11-01</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Event-order"><a href="#Event-order" class="headerlink" title="Event order"></a>Event order</h1><p>On the <a href="https://www.quirksmode.org/js/introevents.html" target="_blank" rel="noopener">Introduction to events</a> page I asked a question that at first sight seems incomprehensible: “If an element and one of its ancestors have an event handler for the same event, which one should fire first?” Not surprisingly, this depends on the browser.</p>
<p>The basic problem is very simple. Suppose you have a element inside an element</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------</span><br><span class="line">| element1                        |</span><br><span class="line">|   -------------------------     |</span><br><span class="line">|   |element2               |     |</span><br><span class="line">|   -------------------------     |</span><br><span class="line">|                                 |</span><br><span class="line">-----------------------------------</span><br></pre></td></tr></table></figure>
<p>and both have an onClick event handler. If the user clicks on element2 he causes a click event in both element1 and element2. But which event fires first? Which event handler should be executed first? What, in other words, is the <em>event order</em>?</p>
<h3 id="Two-models"><a href="#Two-models" class="headerlink" title="Two models"></a>Two models</h3><p>Not surprisingly, back in the bad old days Netscape and Microsoft came to different conclusions.</p>
<ul>
<li>Netscape said that the event on element1 takes place first. This is called event <em>capturing</em>.</li>
<li>Microsoft maintained that the event on element2 takes precedence. This is called event <em>bubbling</em>.</li>
</ul>
<p>The two event orders are radically opposed. Explorer only supports event bubbling. Mozilla, Opera 7 and Konqueror support both. Older Opera’s and iCab support neither.</p>
<h4 id="Event-capturing"><a href="#Event-capturing" class="headerlink" title="Event capturing"></a>Event capturing</h4><p>When you use event capturing</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">               | |</span><br><span class="line">---------------| |-----------------</span><br><span class="line">| element1     | |                |</span><br><span class="line">|   -----------| |-----------     |</span><br><span class="line">|   |element2  \ /          |     |</span><br><span class="line">|   -------------------------     |</span><br><span class="line">|        Event CAPTURING          |</span><br><span class="line">-----------------------------------</span><br></pre></td></tr></table></figure>
<p>the event handler of element1 fires first, the event handler of element2 fires last.</p>
<h4 id="Event-bubbling"><a href="#Event-bubbling" class="headerlink" title="Event bubbling"></a>Event bubbling</h4><p>When you use event bubbling</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">               / \</span><br><span class="line">---------------| |-----------------</span><br><span class="line">| element1     | |                |</span><br><span class="line">|   -----------| |-----------     |</span><br><span class="line">|   |element2  | |          |     |</span><br><span class="line">|   -------------------------     |</span><br><span class="line">|        Event BUBBLING           |</span><br><span class="line">-----------------------------------</span><br></pre></td></tr></table></figure>
<p>the event handler of element2 fires first, the event handler of element1 fires last.</p>
<h3 id="W3C-model"><a href="#W3C-model" class="headerlink" title="W3C model"></a>W3C model</h3><p>W3C has very sensibly decided to take a middle position in this struggle. Any event taking place in the <a href="http://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/" target="_blank" rel="noopener">W3C event model</a> is first captured until it reaches the target element and then bubbles up again.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                 | |  / \</span><br><span class="line">-----------------| |--| |-----------------</span><br><span class="line">| element1       | |  | |                |</span><br><span class="line">|   -------------| |--| |-----------     |</span><br><span class="line">|   |element2    \ /  | |          |     |</span><br><span class="line">|   --------------------------------     |</span><br><span class="line">|        W3C event model                 |</span><br><span class="line">------------------------------------------</span><br></pre></td></tr></table></figure>
<p>You, the web developer, can choose whether to register an event handler in the capturing or in the bubbling phase. This is done through the <code>addEventListener()</code> method explained on the <a href="https://www.quirksmode.org/js/events_advanced.html" target="_blank" rel="noopener">Advanced models</a> page. If its last argument is <code>true</code> the event handler is set for the capturing phase, if it is<code>false</code> the event handler is set for the bubbling phase.</p>
<p>Suppose you do</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">element1.addEventListener(&apos;click&apos;,doSomething2,true)</span><br><span class="line">element2.addEventListener(&apos;click&apos;,doSomething,false)</span><br></pre></td></tr></table></figure>
<p>If the user clicks on element2 the following happens:</p>
<ol>
<li>The <code>click</code> event starts in the capturing phase. The event looks if any ancestor element of element2 has a <code>onclick</code> event handler for the capturing phase.</li>
<li>The event finds one on element1. <code>doSomething2()</code> is executed.</li>
<li>The event travels down to the target itself, no more event handlers for the capturing phase are found. The event moves to its bubbling phase and executes <code>doSomething()</code>, which is registered to element2 for the bubbling phase.</li>
<li>The event travels upwards again and checks if any ancestor element of the target has an event handler for the bubbling phase. This is not the case, so nothing happens.</li>
</ol>
<p>The reverse would be</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">element1.addEventListener(&apos;click&apos;,doSomething2,false)</span><br><span class="line">element2.addEventListener(&apos;click&apos;,doSomething,false)</span><br></pre></td></tr></table></figure>
<p>Now if the user clicks on element2 the following happens:</p>
<ol>
<li>The <code>click</code> event starts in the capturing phase. The event looks if any ancestor element of element2 has a <code>onclick</code> event handler for the capturing phase and doesn’t find any.</li>
<li>The event travels down to the target itself. The event moves to its bubbling phase and executes <code>doSomething()</code>, which is registered to element2 for the bubbling phase.</li>
<li>The event travels upwards again and checks if any ancestor element of the target has an event handler for the bubbling phase.</li>
<li>The event finds one on element1. Now <code>doSomething2()</code> is executed.</li>
</ol>
<h4 id="Compatibility-with-traditional-model"><a href="#Compatibility-with-traditional-model" class="headerlink" title="Compatibility with traditional model"></a>Compatibility with traditional model</h4><p>In the browsers that support the W3C DOM, a traditional event registration</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element1.onclick = doSomething2;</span><br></pre></td></tr></table></figure>
<p>is seen as a registration in the <em>bubbling phase</em>.</p>
<h3 id="Use-of-event-bubbling"><a href="#Use-of-event-bubbling" class="headerlink" title="Use of event bubbling"></a>Use of event bubbling</h3><p>Few web developers consciously use event capturing or bubbling. In Web pages as they are made today, it is simply not necessary to let a bubbling event be handled by several different event handlers. Users might get confused by several things happening after one mouse click, and usually you want to keep your event handling scripts separated. When the user clicks on an element, something happens, when he clicks on another element, something else happens.</p>
<p>Of course this might change in the future, and it’s good to have models available that are forward compatible. But the main practical use of event capturing and bubbling today is the registration of default functions.</p>
<h3 id="It-always-happens"><a href="#It-always-happens" class="headerlink" title="It always happens"></a>It always happens</h3><p>What you first need to understand is that event capturing or bubbling always happens. If you define a general onclick event handler for your entire document</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.onclick = doSomething;</span><br><span class="line">if (document.captureEvents) document.captureEvents(Event.CLICK);</span><br></pre></td></tr></table></figure>
<p>any <code>click</code> event on any element in the document will eventually bubble up to the document and thus fire this general event handler. Only when a previous event handling script explicitly orders the event to stop bubbling, it will not propagate to the document.</p>
<h3 id="Uses"><a href="#Uses" class="headerlink" title="Uses"></a>Uses</h3><p>Because any event ends up on the document, default event handlers become possible. Suppose you have this page:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">------------------------------------</span><br><span class="line">| document                         |</span><br><span class="line">|   ---------------  ------------  |</span><br><span class="line">|   | element1    |  | element2 |  |</span><br><span class="line">|   ---------------  ------------  |</span><br><span class="line">|                                  |</span><br><span class="line">------------------------------------</span><br><span class="line"></span><br><span class="line">element1.onclick = doSomething;</span><br><span class="line">element2.onclick = doSomething;</span><br><span class="line">document.onclick = defaultFunction;</span><br></pre></td></tr></table></figure>
<p>Now if the user clicks on element1 or 2, <code>doSomething()</code> is executed. You can stop the event propagation here, if you wish. If you don’t the event bubbles up to <code>defaultFunction()</code>. If the user clicks anywhere else <code>defaultFunction()</code> is also executed. This might be useful sometimes.</p>
<p>Setting document–wide event handlers is necessary in drag–and–drop scripts. Typically a <code>mousedown</code> event on a layer selects this layer and makes it respond to the <code>mousemove</code> event. Though the <code>mousedown</code> is usually registered on the layer to avoid browser bugs, both other event handlers must be document–wide.</p>
<p>Remember the First Law of Browserology: anything can happen, and it usually does when you’re least prepared for it. So it may happen that the user moves his mouse very wildly and the script doesn’t keep up so that the mouse is not over the layer any more.</p>
<ul>
<li>If the <code>onmousemove</code> event handler is registered to the layer, the layer doesn’t react to the mouse movement any more, causing confusion.</li>
<li>If the <code>onmouseup</code> event handler is registered on the layer, this event isn’t caught either so that the layer keeps reacting to the mouse movements even after the user thinks he dropped the layer. This causes even more confusion.</li>
</ul>
<p>So in this case event bubbling is very useful because registering your event handlers on document level makes sure they’re always executed.</p>
<h3 id="Turning-it-off"><a href="#Turning-it-off" class="headerlink" title="Turning it off"></a>Turning it off</h3><p>But usually you want to turn all capturing and bubbling off to keep functions from interfering with each other. Besides, if your document structure is very complex (lots of nested tables and such) you may save system resources by turning off bubbling. The browser has to go through every single ancestor element of the event target to see if it has an event handler. Even if none are found, the search still takes time.</p>
<p>In the Microsoft model you must set the event’s <code>cancelBubble</code> property to true.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.event.cancelBubble = true</span><br></pre></td></tr></table></figure>
<p>In the W3C model you must call the event’s <code>stopPropagation()</code> method. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.stopPropagation()</span><br></pre></td></tr></table></figure>
<p>This stops all propagation of the event in the bubbling phase. For a complete cross-browser experience do</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function doSomething(e)</span><br><span class="line">&#123;</span><br><span class="line">	if (!e) var e = window.event;</span><br><span class="line">	e.cancelBubble = true;</span><br><span class="line">	if (e.stopPropagation) e.stopPropagation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Setting the <code>cancelBubble</code> property in browsers that don’t support it doesn’t hurt. The browser shrugs and creates the property. Of course it doesn’t actually cancel the bubbling, but the assignment itself is safe.</p>
<h3 id="currentTarget"><a href="#currentTarget" class="headerlink" title="currentTarget"></a>currentTarget</h3><p>As we’ve seen earlier, an event has a <code>target</code> or <code>srcElement</code> that contains a reference to the element the event happened on. In our example this is element2, since the user clicked on it.</p>
<p>It is very important to understand that during the capturing and bubbling phases (if any) this target does not change: it always remains a reference to element2.</p>
<p>But suppose we register these event handlers:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">element1.onclick = doSomething;</span><br><span class="line">element2.onclick = doSomething;</span><br></pre></td></tr></table></figure>
<p>If the user clicks on element2 <code>doSomething()</code> is executed twice. But how do you know which HTML element is currently handling the event? <code>target/srcElement</code> don’t give a clue, they always refer to element2 since it is the original source of the event.</p>
<p>To solve this problem W3C has added the <code>currentTarget</code> property. It contains a reference to the HTML element the event is currently being handled by: exactly what we need. Unfortunately the Microsoft model doesn’t contain a similar property.</p>
<p>You can also use <a href="https://www.quirksmode.org/js/this.html" target="_blank" rel="noopener">the <code>this</code> keyword</a>. In the example above it refers to the HTML element the event is handled on, just like <code>currentTarget</code>.</p>
<h3 id="Problems-of-the-Microsoft-model"><a href="#Problems-of-the-Microsoft-model" class="headerlink" title="Problems of the Microsoft model"></a>Problems of the Microsoft model</h3><p>But when you use the Microsoft event registration model the <code>this</code> keyword doesn’t refer to the HTML element. Combined with the lack of a <code>currentTarget</code>–like property in the Microsoft model, this means that if you do</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">element1.attachEvent(&apos;onclick&apos;,doSomething)</span><br><span class="line">element2.attachEvent(&apos;onclick&apos;,doSomething)</span><br></pre></td></tr></table></figure>
<p>you <em>cannot</em> know which HTML element currently handles the event. This is the most serious problem with the Microsoft event registration model and for me it’s reason enough never to use it, not even in IE/Win only applications.</p>
<p>I hope Microsoft will soon add a <code>currentTarget</code>–like property — or maybe even follow the standard? Web developers need this information.</p>
<h3 id="Continue"><a href="#Continue" class="headerlink" title="Continue"></a>Continue</h3><p>If you wish to go through all event pages in order, you should now continue with the <a href="https://www.quirksmode.org/js/events_mouse.html" target="_blank" rel="noopener">Mouse events</a> page.</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/29/addEventListener/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雯子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Athena">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/29/addEventListener/" itemprop="url">
                  一个由addEventListener参数问题所引发的阅读
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-29 21:21:31" itemprop="dateCreated datePublished" datetime="2018-10-29T21:21:31+08:00">2018-10-29</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-10-31 23:03:46" itemprop="dateModified" datetime="2018-10-31T23:03:46+08:00">2018-10-31</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天我在看一篇讲MVC和观察者模式的文章的时候，里面有一个例子代码，是这样的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(model) &#123;</span><br><span class="line">    <span class="keyword">this</span>.model = model;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//EVENTLISTENER INTERFACE</span></span><br><span class="line">  handleEvent(e) &#123;</span><br><span class="line">    e.stopPropagation();</span><br><span class="line">    <span class="keyword">switch</span> (e.type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"click"</span>:</span><br><span class="line">        <span class="keyword">this</span>.clickHandler(e.target);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">console</span>.log(e.target);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//GET MODEL HEADING</span></span><br><span class="line">  getModelHeading() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.model.heading;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//CHANGE THE MODEL</span></span><br><span class="line">  clickHandler(target) &#123;</span><br><span class="line">    <span class="keyword">this</span>.model.heading = <span class="string">"World"</span>;</span><br><span class="line">    <span class="keyword">this</span>.model.notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>中间实例化了这个class，为controller<br>DOM事件监听的调用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.heading.addEventListener(<span class="string">"click"</span>, controller);</span><br></pre></td></tr></table></figure></p>
<p>可以发现，这里的addEventListener传的第二个参数是一个对象，那么这个对象怎么就能解析事件呢，以前的我只知道第二个参数应该传一个函数，而从没使用过对象的这种方式。于是查了一下MDN，果然不简单。</p>
<h2 id="EventTarget"><a href="#EventTarget" class="headerlink" title="EventTarget"></a>EventTarget</h2><p>要说 addEventListener，首先要从 <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget" target="_blank" rel="noopener">EventTarget</a> 说起。</p>
<blockquote>
<p>EventTarget 是一个由对象实现的接口，这些对象可以接收事件，并为它们提供侦听器。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element" target="_blank" rel="noopener"><code>Element</code></a>、 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document" target="_blank" rel="noopener"><code>document</code></a>和 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window" target="_blank" rel="noopener"><code>window</code></a> 是最常见的 event targets, 但其它对象也可成为 event targets， 例如 <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener"><code>XMLHttpRequest</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/API/AudioNode" target="_blank" rel="noopener"><code>AudioNode</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/API/AudioContext" target="_blank" rel="noopener"><code>AudioContext</code></a> 等。</p>
<p>Web平台提供了几种获取DOM事件通知的方法。两种常见的方式是：通用 <code>addEventListener()</code> 和一组特定的 <strong>on-event</strong> 处理程序。</p>
</blockquote>
<p>然后 MDN 给出了一个 EventTarget 的简单实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventTarget = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.listeners = &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EventTarget.prototype.listeners = <span class="literal">null</span>;</span><br><span class="line">EventTarget.prototype.addEventListener = <span class="function"><span class="keyword">function</span>(<span class="params">type, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(type <span class="keyword">in</span> <span class="keyword">this</span>.listeners)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.listeners[type] = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.listeners[type].push(callback);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EventTarget.prototype.removeEventListener = <span class="function"><span class="keyword">function</span>(<span class="params">type, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(type <span class="keyword">in</span> <span class="keyword">this</span>.listeners)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> stack = <span class="keyword">this</span>.listeners[type];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = stack.length; i &lt; l; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (stack[i] === callback)&#123;</span><br><span class="line">      stack.splice(i, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EventTarget.prototype.dispatchEvent = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(event.type <span class="keyword">in</span> <span class="keyword">this</span>.listeners)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> stack = <span class="keyword">this</span>.listeners[event.type].slice();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = stack.length; i &lt; l; i++) &#123;</span><br><span class="line">    stack[i].call(<span class="keyword">this</span>, event);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> !event.defaultPrevented;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我这一看，这不就是这几天正在研究的观察者模式么，EventTarget 是一个构造函数，是被观察的主体，在原型上绑定了三个方法：</p>
<ul>
<li><code>addEventListener()</code> - 在 EventTarget 上注册特定事件类型的事件处理程序。</li>
<li><code>removeEventListener()</code> - 从 EventTarget 中删除一个事件侦听器。</li>
<li><code>dispatchEvent()</code> - 将事件分派到此 EventTarget。</li>
</ul>
<p>其中的 listener 就是监听的事件，类型和回调函数。</p>
<h2 id="EventListener"><a href="#EventListener" class="headerlink" title="EventListener"></a>EventListener</h2><p>接下来，我们再来看 <strong><a href="https://developer.mozilla.org/en-US/docs/Web/API/EventListener" target="_blank" rel="noopener">EventListener</a></strong></p>
<blockquote>
<p>EventListener 接口表示一个对象，可以处理 EventTarget 对象发出的事件。</p>
<p>由于需要与遗留内容兼容，EventListener 接受一个函数，或者带有 handleEvent() 属性函数的对象。如下例所示。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span>&gt;</span>Click here!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buttonElement = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过提供回调函数为'click'事件添加处理程序。</span></span><br><span class="line"><span class="comment">// Whenever the element is clicked, a pop-up with "Element clicked!" will</span></span><br><span class="line"><span class="comment">// appear.</span></span><br><span class="line">buttonElement.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'Element clicked through function!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// For compatibility, a non-function object with a `handleEvent` property is</span></span><br><span class="line"><span class="comment">// treated just the same as a function itself.</span></span><br><span class="line">buttonElement.addEventListener(<span class="string">'click'</span>, &#123;</span><br><span class="line">  handleEvent: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Element clicked through handleEvent property!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里我们看到一开始抛出的，addEventListener 的第二个参数可以是一个对象，里面有一个函数属性，名字为 <code>handleEvent</code>。</p>
<p>按理说这篇文章到这，就差不多了，但是我发现好多跟 <code>addEventListener</code> 相关的东西，于是再进一步探索一下。</p>
<h2 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener"></a>addEventListener</h2><p>先列一下语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target.addEventListener(type, listener[, options]);</span><br><span class="line">target.addEventListener(type, listener[, useCapture]);</span><br><span class="line">target.addEventListener(type, listener[, useCapture, wantsUntrusted  ]); // Gecko/Mozilla only</span><br></pre></td></tr></table></figure>
<p>再看一下每个参数：</p>
<ul>
<li><p>type-表示要侦听的事件类型，是一个大小写敏感的字符串</p>
</li>
<li><p>listener - 当发生指定类型的事件时接收通知（实现 Event 接口的对象）的对象。这必须是实现 EventListener 接口的对象，或 JavaScript 函数。</p>
</li>
<li><p>options</p>
<p>指定事件侦听器特征的选项对象。可用的选项如下：</p>
<ul>
<li><code>capture</code>:  <code>Boolean</code>，表示 <code>listener</code> 会在该类型的事件捕获阶段传播到该 <code>EventTarget</code> 时触发。</li>
<li><code>once</code>:  <code>Boolean</code>，表示 <code>listener 在添加之后最多只调用一次。如果是</code> <code>true，</code> <code>listener</code> 会在其被调用之后自动移除。</li>
<li><code>passive</code>: <code>Boolean</code>，如果为真，则表示 <code>listener</code> 永远不会调用 <code>preventDefault()。如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告。</code></li>
<li><code>mozSystemGroup</code>: 只能在 XBL 或者是 Firefox’ chrome 使用，这是个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Boolean" target="_blank" rel="noopener"><code>Boolean</code></a>，表示 <code>listener</code>被添加到 system group。</li>
</ul>
</li>
</ul>
<p>在说到第三个参数的时候，就必须了解 DOM 的事件流，这里我们从W3C工作草案 <a href="http://www.w3.org/TR/DOM-Level-3-Events/#event-flow" target="_blank" rel="noopener">DOM Level 3 Events</a> 开始了解。</p>
<ul>
<li><p>useCapture</p>
<p>一个布尔值，默认为false。指示在将此类型的事件分派到DOM树中它下面的任何EventTarget之前，是否会将此类型的事件分派给已注册的侦听器。通过树向上冒泡的事件不会触发指定使用捕获的侦听器。当两个元素都为该事件注册了句柄时，事件冒泡和捕获是传播在嵌套在另一个元素中的元素中发生的事件的两种方法。事件传播模式确定元素接收事件的顺序。</p>
</li>
</ul>
<h2 id="DOM-Event-Architecture"><a href="#DOM-Event-Architecture" class="headerlink" title="DOM Event Architecture"></a>DOM Event Architecture</h2><h3 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h3><p>在看规范正文之前，不得不说，还得看一下一些术语和翻译的对应，不然用以被这些名字搞懵。</p>
<h4 id="Event-事件"><a href="#Event-事件" class="headerlink" title="Event-事件"></a>Event-事件</h4><p>看一下<a href="https://dom.spec.whatwg.org/#interface-event" target="_blank" rel="noopener">接口描述</a>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[Constructor(DOMString type, optional EventInit eventInitDict),</span><br><span class="line"> Exposed=(Window,Worker,AudioWorklet)]</span><br><span class="line">interface Event &#123;</span><br><span class="line">  readonly attribute DOMString type;</span><br><span class="line">  readonly attribute EventTarget? target;</span><br><span class="line">  readonly attribute EventTarget? srcElement; // historical</span><br><span class="line">  readonly attribute EventTarget? currentTarget;</span><br><span class="line">  sequence&lt;EventTarget&gt; composedPath();</span><br><span class="line"></span><br><span class="line">  const unsigned short NONE = 0;</span><br><span class="line">  const unsigned short CAPTURING_PHASE = 1;</span><br><span class="line">  const unsigned short AT_TARGET = 2;</span><br><span class="line">  const unsigned short BUBBLING_PHASE = 3;</span><br><span class="line">  readonly attribute unsigned short eventPhase;</span><br><span class="line"></span><br><span class="line">  void stopPropagation();</span><br><span class="line">           attribute boolean cancelBubble; // historical alias of .stopPropagation</span><br><span class="line">  void stopImmediatePropagation();</span><br><span class="line"></span><br><span class="line">  readonly attribute boolean bubbles;</span><br><span class="line">  readonly attribute boolean cancelable;</span><br><span class="line">           attribute boolean returnValue;  // historical</span><br><span class="line">  void preventDefault();</span><br><span class="line">  readonly attribute boolean defaultPrevented;</span><br><span class="line">  readonly attribute boolean composed;</span><br><span class="line"></span><br><span class="line">  [Unforgeable] readonly attribute boolean isTrusted;</span><br><span class="line">  readonly attribute DOMHighResTimeStamp timeStamp;</span><br><span class="line"></span><br><span class="line">  void initEvent(DOMString type, optional boolean bubbles = false, optional boolean cancelable = false); // historical</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">dictionary EventInit &#123;</span><br><span class="line">  boolean bubbles = false;</span><br><span class="line">  boolean cancelable = false;</span><br><span class="line">  boolean composed = false;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>事件对象简单地称为事件。它允许发送发生了什么事情的信号，例如，图像已经完成下载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event = new Event(type [, eventInitDict])</span><br></pre></td></tr></table></figure>
<p>返回一个新事件，其 <code>type</code> 属性值设置为 type。eventInitDictargument 允许通过同名对象成员设置 <code>bubbles</code> 和 <code>cancelable</code> 属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event . type</span><br></pre></td></tr></table></figure>
<p>返回事件的类型， e.g. “<code>click</code>“, “<code>hashchange</code>“, or “<code>submit</code>“.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event . target</span><br></pre></td></tr></table></figure>
<p>返回发送事件的对象(其目标)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event . currentTarget</span><br></pre></td></tr></table></figure>
<p>返回当前正在调用其事件侦听器回调的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event . composedPath()</span><br></pre></td></tr></table></figure>
<p>Returns the <a href="https://dom.spec.whatwg.org/#event-path-item" target="_blank" rel="noopener">item</a> objects of event’s <a href="https://dom.spec.whatwg.org/#event-path" target="_blank" rel="noopener">path</a> (objects on which listeners will be invoked), except for any <a href="https://dom.spec.whatwg.org/#concept-node" target="_blank" rel="noopener">nodes</a> in <a href="https://dom.spec.whatwg.org/#concept-shadow-tree" target="_blank" rel="noopener">shadow trees</a> of which the <a href="https://dom.spec.whatwg.org/#concept-shadow-root" target="_blank" rel="noopener">shadow root</a>’s <a href="https://dom.spec.whatwg.org/#shadowroot-mode" target="_blank" rel="noopener">mode</a> is “<code>closed</code>“ that are not reachable from event’s <code>currentTarget</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event . eventPhase</span><br></pre></td></tr></table></figure>
<p>Returns the <a href="https://dom.spec.whatwg.org/#concept-event" target="_blank" rel="noopener">event</a>’s phase, which is one of <code>NONE</code>, <code>CAPTURING_PHASE</code>, <code>AT_TARGET</code>, and <code>BUBBLING_PHASE</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event . stopPropagation()</span><br></pre></td></tr></table></figure>
<p>在树中分派时，调用此方法可防止事件到达当前对象以外的任何对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event . stopImmediatePropagation()</span><br></pre></td></tr></table></figure>
<p>Invoking this method prevents event from reaching any registered <a href="https://dom.spec.whatwg.org/#concept-event-listener" target="_blank" rel="noopener">event listeners</a> after the current one finishes running and, when <a href="https://dom.spec.whatwg.org/#concept-event-dispatch" target="_blank" rel="noopener">dispatched</a> in a <a href="https://dom.spec.whatwg.org/#concept-tree" target="_blank" rel="noopener">tree</a>, also prevents eventfrom reaching any other objects.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event . bubbles</span><br></pre></td></tr></table></figure>
<p>根据事件初始化的方式返回 true 或 false。如果事件以相反的树顺序通过目标的祖先，则为真，否则为假。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event . cancelable</span><br></pre></td></tr></table></figure>
<p>根据事件初始化的方式返回 true 或 false。它的返回值并不总是有意义，但是 true 可以指示在事件被分派期间，可以通过调用 preventDefault() 方法来取消部分操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event . preventDefault()</span><br></pre></td></tr></table></figure>
<p>If invoked when the <code>cancelable</code> attribute value is true, and while executing a listener for the event with <code>passive</code> set to false, signals to the operation that caused event to be <a href="https://dom.spec.whatwg.org/#concept-event-dispatch" target="_blank" rel="noopener">dispatched</a> that it needs to be canceled.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event . defaultPrevented</span><br></pre></td></tr></table></figure>
<p>Returns true if <code>preventDefault()</code> was invoked successfully to indicate cancelation, and false otherwise.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event . composed</span><br></pre></td></tr></table></figure>
<p>Returns true or false depending on how event was initialized. True if event invokes listeners past a <code>ShadowRoot</code> <a href="https://dom.spec.whatwg.org/#boundary-point-node" target="_blank" rel="noopener">node</a> that is the <a href="https://dom.spec.whatwg.org/#concept-tree-root" target="_blank" rel="noopener">root</a> of its <a href="https://dom.spec.whatwg.org/#event-target" target="_blank" rel="noopener">target</a>, and false otherwise.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event . isTrusted</span><br></pre></td></tr></table></figure>
<p>Returns true if event was <a href="https://dom.spec.whatwg.org/#concept-event-dispatch" target="_blank" rel="noopener">dispatched</a> by the user agent, and false otherwise.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event . timeStamp</span><br></pre></td></tr></table></figure>
<p>Returns the event’s timestamp as the number of milliseconds measured relative to the <a href="https://w3c.github.io/hr-time/#dfn-time-origin" target="_blank" rel="noopener">time origin</a>.</p>
<h4 id="dispatch-分派、派发、分发"><a href="#dispatch-分派、派发、分发" class="headerlink" title="dispatch-分派、派发、分发"></a><a href="https://www.w3.org/TR/DOM-Level-3-Events/#dispatch" target="_blank" rel="noopener">dispatch</a>-分派、派发、分发</h4><p>创建一个事件，该事件具有与其类型和上下文相匹配的属性和方法，并以指定的方式通过DOM树进行传播。可以与术语 fire 互换，例如，触发一个单击事件（fire a click event）或分派一个加载事件（dispatch a load event）。</p>
<h4 id="event-target-事件目标"><a href="#event-target-事件目标" class="headerlink" title="event target-事件目标"></a><a href="https://www.w3.org/TR/DOM-Level-3-Events/#event-target" target="_blank" rel="noopener">event target</a>-事件目标</h4><p>事件的目标对象，使用事件派发和DOM事件流。<strong>事件目标</strong>是 event 的 target 属性的值。也就是 event.target。</p>
<h4 id="propagation-path-传播路径"><a href="#propagation-path-传播路径" class="headerlink" title="propagation path-传播路径"></a><a href="https://www.w3.org/TR/DOM-Level-3-Events/#propagation-path" target="_blank" rel="noopener">propagation path</a>-传播路径</h4><p><strong>当前事件目标</strong>的有序集合，事件对象将在进出事件目标的过程中按顺序传递。当事件传播时，<strong>传播路径</strong>中的每个当前事件目标依次设置为currentTarget。<strong>传播路径</strong>最初由事件类型定义的一个或多个事件阶段组成，但可能会被中断。也称为事件目标链。</p>
<h4 id="current-event-target-当前事件目标"><a href="#current-event-target-当前事件目标" class="headerlink" title="current event target-当前事件目标"></a><a href="https://www.w3.org/TR/DOM-Level-3-Events/#current-event-target" target="_blank" rel="noopener">current event target</a>-当前事件目标</h4><p>在事件流中，<strong>当前事件目标</strong>是与当前派发的事件处理程序关联的对象。此对象可能是目标事件本身或其祖先之一。当事件通过事件流的各个阶段从一个对象传播到另一个对象时，<strong>当前事件目标</strong>会发生变化。<strong>当前事件目标</strong>是 currentTarget 属性的值。</p>
<h4 id="event-handler-event-listener-事件处理程序-事件侦听器"><a href="#event-handler-event-listener-事件处理程序-事件侦听器" class="headerlink" title="event handler/event listener-事件处理程序/事件侦听器"></a><a href="https://www.w3.org/TR/DOM-Level-3-Events/#event-handler" target="_blank" rel="noopener">event handler/event listener</a>-事件处理程序/事件侦听器</h4><p>实现EventListener接口并提供handleEvent()回调方法的对象。事件处理程序是特定于语言的。事件处理程序在特定对象(<strong>当前事件目标</strong>)的上下文中调用，并提供事件对象本身。</p>
<h4 id="phase-阶段"><a href="#phase-阶段" class="headerlink" title="phase-阶段"></a>phase-阶段</h4><p>在事件的上下文中，阶段是一组沿着DOM树的逻辑遍历，从 Window 到 <code>Document</code> 对象、根元素，然后下到事件对象（捕获阶段），再到事件对象本身（目标阶段），然后沿原路返回（冒泡阶段）。</p>
<h3 id="事件分发和DOM事件流-Event-dispatch-and-DOM-event-flow"><a href="#事件分发和DOM事件流-Event-dispatch-and-DOM-event-flow" class="headerlink" title="事件分发和DOM事件流-Event dispatch and DOM event flow"></a>事件分发和DOM事件流-Event dispatch and DOM event flow</h3><p>本章节会简单介绍<strong>事件分派</strong>机制，并描述事件是如何通过DOM树进行传播的。应用程序可以使用 <code>dispatchEvent()</code> 方法分派事件对象，事件对象将通过DOM事件流确定的DOM树传播。</p>
<p><img src="https://www.w3.org/TR/DOM-Level-3-Events/images/eventflow.svg" alt="Graphical representation of an event dispatched in a DOM tree using the DOM event flow"></p>
<p>事件对象被分发到一个<strong>事件目标</strong>上。但是在开始分派之前，必须先确定事件对象的<strong>传播路径</strong>。</p>
<p><strong>传播路径</strong>是事件通过<strong>当前事件目标</strong>的有序列表。这个传播路径反映了文档的层次树结构。列表中的最后一项是<strong>事件目标</strong>，在这之前的都称为目标的祖先项，挨着事件目标的称作目标的父项。</p>
<p>一旦传播路径决定了，事件对象就会经过一个或多个<strong>事件阶段</strong>。有三个事件阶段：捕获阶段、目标阶段和冒泡阶段。事件对象会像下面描述的这样来完成这些阶段。如果不支持某个阶段，或者事件对象的传播已经停止，则跳过该阶段。例如，如果 <code>bubbles</code> 属性设成了 false，就会跳过冒泡阶段，如果在分派之前就调用了 <code>stopPropagation()</code>，所有阶段都会被跳过。</p>
<ul>
<li><p>捕获阶段（capture phase）：事件对象通过对象的祖先项，从 Window 传播到目标的父项。该阶段也被称为 capturing phase （反正中文翻译过来都是捕获阶段）</p>
</li>
<li><p>目标阶段（target phase）：事件对象到达事件对象的事件目标上面。该阶段也被称作 at-target phase （反正翻译过来还是目标阶段）。如果事件类型指出该事件不进行冒泡，则事件对象将在此阶段结束后停止。</p>
</li>
<li>冒泡阶段（bubble phase）：事件对象以相反的顺序通过目标的祖先项传播，从目标的父项开始，到 Window 结束。该阶段也被称为 bubbling phase（反正翻译过来还是冒泡阶段）</li>
</ul>
<h3 id="默认动作和可取消事件"><a href="#默认动作和可取消事件" class="headerlink" title="默认动作和可取消事件"></a>默认动作和可取消事件</h3><p>事件通常由实现作为用户操作的结果进行分派，比如为了响应任务的完成，或者在异步活动期间发送进程信号（例如网络请求）。可以使用一些事件来控制实现接下来可能采取的行为(或撤消实现已经采取的动作)。这个类别中的事件称为可取消的（cancelable），它们取消的行为称为默认行为（default action）。可取消事件对象可以与一个或多个“默认动作”相关联。要取消事件，请调用 preventDefault() 方法。</p>
<blockquote>
<p>例子1：当用户按下指向设备(通常是鼠标)上的按钮后，立即会发出mousedown事件。实现可能采取的一个默认操作是设置一个状态机，允许用户拖动图像或选择文本。默认操作取决于接下来会发生什么——例如，如果用户的指向设备位于文本之上，可能会开始文本选择。如果用户的指向设备位于图像上方，则可以开始图像拖动操作。防止mousedown事件的默认操作将阻止这些操作的发生。</p>
</blockquote>
<p>默认操作通常在事件分派完成之后执行，但在特殊情况下，它们也可以在事件分派之前立即执行。</p>
<p>总结：感觉光看是不行的，还是要多实践，才能明白。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/23/promise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雯子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Athena">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/23/promise/" itemprop="url">
                  [译]Promise-basics
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-05-23 16:33:58" itemprop="dateCreated datePublished" datetime="2018-05-23T16:33:58+08:00">2018-05-23</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-11-06 12:05:45" itemprop="dateModified" datetime="2018-11-06T12:05:45+08:00">2018-11-06</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文：<a href="https://javascript.info/promise-basics" target="_blank" rel="noopener">Promise</a></p>
<p>想象一下，你是一个顶级歌手，你的粉丝们成天管要你的下一张专辑。<br>为了得到解脱，你向他们承诺，一旦专辑发行了就会立即寄给他们。你给粉丝们一张表让他们填写地址，这样一来一旦歌曲发行了，所有预定的人都能马上拿到。如果发生了什么意外，比如歌曲再也不会发行了，他们也会收到通知。</p>
<p>这样就皆大欢喜了，再也不会有人来烦你了，粉丝们也不会错过你的专辑单曲。</p>
<p>以上是一个真实世界的类比，我们在编程的过程中经常会遇到类似的情景：</p>
<ol>
<li>“生产代码”会做一些事情，会需要一些时间。例如，加载异步脚本。这就相当于那个“歌手”。</li>
<li>“消费代码”则是等准备好了之后获取结果。很多函数都可能需要这个结果。这就相当于那些“粉丝”。</li>
<li><em>promise</em> 就是一个特殊的JavaScript对象，它把它们连接起来。这就相当于那个“列表”。生产代码做出来之后发给每个人，这样他们就都能订阅这个结果了。</li>
</ol>
<p>虽然这个类比并不是非常的准确，因为JavaScript promise比一个简单的列表复杂得多，它们有额外的特性和限制，但是这个比喻还是可以帮助我们理解的。</p>
<p>一个promise对象的构建语法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 执行者 (生产代码, "歌手")</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>传给<code>new Promise</code>的函数叫做<em>执行者</em>。当promise被创建之后，<em>执行者</em>就被立即调用。它包括了生产代码，也就是最终要通过得到一个结果来结束。基于上面的类比，这个执行者就是一个“歌手”。</p>
<p>生成的<code>promise</code>对象有内部属性：</p>
<ul>
<li><code>state</code> – 初始值是“pending”，之后会变成“fulfilled”或者“rejected”</li>
<li><code>result</code> – 任意值，初始值是<code>undefined</code></li>
</ul>
<p>当执行者结束这个任务后，就会调用下面两个函数的一个：</p>
<ul>
<li><code>resolve(value)</code> – 表明任务成功结束:<ul>
<li>将 <code>state</code> 置成 <code>&quot;fulfilled&quot;</code>,</li>
<li>将 <code>result</code> 置成 <code>value</code>.</li>
</ul>
</li>
<li><p><code>reject(error)</code> – 表明发生了错误:</p>
<ul>
<li>将 <code>state</code> 置成 <code>&quot;rejected&quot;</code>,</li>
<li>将 <code>result</code> 置成 <code>error</code>.</li>
</ul>
<p><img src="http://ph762tedc.bkt.clouddn.com/FsOFGBP9V6xCF82MB9nEza1OQY4y" alt=""></p>
</li>
</ul>
<p>下面是一个简单的执行者的例子，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当promise被构造的时候，这个函数就被立即执行</span></span><br><span class="line"></span><br><span class="line">  alert(resolve); <span class="comment">// function () &#123; [native code] &#125;</span></span><br><span class="line">  alert(reject);  <span class="comment">// function () &#123; [native code] &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1秒之后这个任务完成，输出结果"done!"</span></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"done!"</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>通过运行上面的代码，我们可以看出两件事情：</p>
<ol>
<li>这个执行者被立即自动调用了（通过 <code>new Promise</code>）</li>
<li>执行者接收两个参数：<code>resolve</code> 和 <code>reject</code> – 这些函数来自JavaScript引擎。我们不需要去创建它们。而且该由执行者来调用它们。</li>
</ol>
<p>1秒之后，执行者调用<code>resolve(&quot;done&quot;)</code>生成结果：</p>
<p><img src="http://ph762tedc.bkt.clouddn.com/Fkb1mvFfrG40vbZtFzZynEHdD0dP" alt=""></p>
<p>这是任务成功完成的一个例子。</p>
<p>现在再看一个执行者抛出异常的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1秒之后任务结束，抛出异常</span></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Whoops!"</span>)), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><img src="http://ph762tedc.bkt.clouddn.com/FsOFGBP9V6xCF82MB9nEza1OQY4y" alt=""></p>
<p>总结一下就是，执行者会执行一个任务（通常是需要花费一定时间的），然后调用 <code>resolve</code> 或者 <code>reject</code>来改变相应的promise对象的状态。</p>
<p>不管是<code>resolve</code> 还是 <code>reject</code>都会被叫做 “settled”，与 “pending”相对应。</p>
<h4 id="只能有一个结果或者异常"><a href="#只能有一个结果或者异常" class="headerlink" title="只能有一个结果或者异常"></a>只能有一个结果或者异常</h4><p>执行者只能调用一个<code>resolve</code> 或者 <code>reject</code>。promise的状态改变就是最终形态。<br>后面的任何调用都是无效的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">"done"</span>);</span><br><span class="line"></span><br><span class="line">  reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"…"</span>)); <span class="comment">// 无效</span></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"…"</span>)); <span class="comment">// 无效</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>至于一个任务执行完成只能有一个结果或者异常这个事情来说，在编程领域，还存在其它数据结构允许很多“流”结果，例如数据流（streams）和队列（queues）。相对于promise，它们也是各有利弊。Javascript核心不支持它们，而且缺少一些只有promise能提供的语言特性，这里我们不做过多的涉及。</p>
<p>还有就是如果我们调用<code>resolve/reject</code>时传入了多个参数，只有第一个参数有用，后面的都会被忽略的。</p>
<h4 id="Reject-使用-Error-对象"><a href="#Reject-使用-Error-对象" class="headerlink" title="Reject 使用 Error 对象"></a>Reject 使用 <code>Error</code> 对象</h4><p>通常来说我们可以像调用<code>resolve</code>一样传入任何参数来调用<code>reject</code>。但还是推荐使用<code>Error</code> 对象。原因的话后面会提。</p>
<h4 id="Resolve-reject-可以是立即执行的"><a href="#Resolve-reject-可以是立即执行的" class="headerlink" title="Resolve/reject 可以是立即执行的"></a>Resolve/reject 可以是立即执行的</h4><p>在练习中，执行者通常是做一些异步操作，在一段时间之后才调用<code>resolve/reject</code>，但其实并不一定是这样。我们可以立即调用<code>resolve</code> or <code>reject</code>函数，例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="number">123</span>); <span class="comment">// 立即给出结果：123</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>一般这种情况发生在，当我们开始要执行一个任务的时候，来看一下是不是多有的事情都准备好了。然后得到一个resolvedpromise表示可以做下面的事情了。</p>
<h3 id="state-和-result-是内部变量"><a href="#state-和-result-是内部变量" class="headerlink" title="state 和 result 是内部变量"></a><code>state</code> 和 <code>result</code> 是内部变量</h3><p><code>state</code> 和 <code>result</code>属性是一个promise对象的内部变量。我们不能在代码中直接访问它们，但是可以使用<code>.then/catch</code>方法，下面会说。</p>
<h2 id="消费者-“-then”-和-“-catch”"><a href="#消费者-“-then”-和-“-catch”" class="headerlink" title="消费者: “.then” 和 “.catch”"></a>消费者: “.then” 和 “.catch”</h2><p>promise对象作为生产代码（执行者）和消费函数（那些想要接收结果或者错误的函数）之间的连接桥梁，消费函数可以使用方法<code>promise.then</code> and <code>promise.catch</code>来注册。</p>
<p><code>.then</code>的语法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123; <span class="comment">/* 处理成功的 result */</span> &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123; <span class="comment">/* 处理 error */</span> &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>如果promise执行成功，得到result，就会执行第一个参数函数，如果promise返回错误就会执行第二个参数函数</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"done!"</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// resolve runs the first function in .then</span></span><br><span class="line">promise.then(</span><br><span class="line">  result =&gt; alert(result), <span class="comment">// 1秒之后显示 "done!"</span></span><br><span class="line">  error =&gt; alert(error) <span class="comment">// 不会执行</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>reject的例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Whoops!"</span>)), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// reject runs the second function in .then</span></span><br><span class="line">promise.then(</span><br><span class="line">  result =&gt; alert(result), <span class="comment">// 不会执行</span></span><br><span class="line">  error =&gt; alert(error) <span class="comment">// 1秒之后显示 "done!" "Error: Whoops!"</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>如果我们只需要成功的情况，那么也可以只提供一个参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"done!"</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(alert); <span class="comment">// 1秒之后显示 "done!"</span></span><br></pre></td></tr></table></figure>
<p>如果只对errors感兴趣，那么可以使用<code>.then(null, function)</code>或者<code>.catch(function)</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Whoops!"</span>)), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// .catch(f) 与 promise.then(null, f)是一样的</span></span><br><span class="line">promise.catch(alert); <span class="comment">// 1秒之后显示 "done!" "Error: Whoops!"</span></span><br></pre></td></tr></table></figure>
<p><code>.catch(f)</code> 与 <code>.then(null, f)</code>是完全等同的。</p>
<h3 id="settled的-promise会立即执行-then"><a href="#settled的-promise会立即执行-then" class="headerlink" title="settled的 promise会立即执行 then"></a>settled的 promise会立即执行 <code>then</code></h3><p>如果一个promise在pending，<code>.then/catch</code>处理器会等待result。另外，如果一个promise状态已经是settled， 它们会立即执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个立即 resolved 的 promise</span></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="string">"done!"</span>));</span><br><span class="line"></span><br><span class="line">promise.then(alert); <span class="comment">// done! (立即显示出来)</span></span><br></pre></td></tr></table></figure>
<p>对于那些有时需要时间，有时立即完成的任务，这样处理是非常方便的，并且能够保证两种情况都能正常运行。</p>
<h3 id="then-catch的处理器永远是异步的"><a href="#then-catch的处理器永远是异步的" class="headerlink" title=".then/catch的处理器永远是异步的"></a><code>.then/catch</code>的处理器永远是异步的</h3><p>更严格来说，当<code>.then/catch</code>处理器要执行的时候，首先会加入一个内部序列。当当前的代码执行完毕之后，JavaScript引擎从序列中取出这些处理器并执行，和<code>setTimeout(..., 0)</code>类似。</p>
<p>换句话说，当<code>.then(handler)</code>将要触发的时候，它的行为类似于<code>setTimeout(handler, 0)</code></p>
<p>在下面的例子中，promise立即resolved，所以<code>.then(alert)</code>也会马上触发：<code>alert</code>回调加入序列，然后等到代码执行结束后，立即执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个立即resolved的promise</span></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="string">"done!"</span>));</span><br><span class="line"></span><br><span class="line">promise.then(alert); <span class="comment">// done! (在当前代码运行结束之后)</span></span><br><span class="line"></span><br><span class="line">alert(<span class="string">"code finished"</span>); <span class="comment">// 这个alert会先显示出来</span></span><br></pre></td></tr></table></figure>
<p>所以在<code>.then</code>后面的代码通常是先于then执行的，即使是在立即resolve的promise情况下。通常这不是很重要，只有一些情况可能会有用。</p>
<p>下面我们来看一些更多的例子，promise如何帮助我们编写异步代码</p>
<h2 id="例子-loadScript"><a href="#例子-loadScript" class="headerlink" title="例子: loadScript"></a>例子: loadScript</h2><p>比如下面的<code>loadScript</code>函数，用的是callback回调函数的写法，用来加载一个脚本：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">src, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">  script.src = src;</span><br><span class="line"></span><br><span class="line">  script.onload = <span class="function"><span class="params">()</span> =&gt;</span> callback(<span class="literal">null</span>, script);</span><br><span class="line">  script.onerror = <span class="function"><span class="params">()</span> =&gt;</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Script load error `</span> + src));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">document</span>.head.append(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们用promise重写一下</p>
<p><code>loadScript</code>新方法不需要回调函数作为参数了。当加载文件完成后，会创建并返回一个promise对象。外面的代码可以用<code>.then</code>来添加后续处理的方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.src = src;</span><br><span class="line"></span><br><span class="line">    script.onload = <span class="function"><span class="params">()</span> =&gt;</span> resolve(script);</span><br><span class="line">    script.onerror = <span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Script load error: "</span> + src));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.head.append(script);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = loadScript(<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js"</span>);</span><br><span class="line"></span><br><span class="line">promise.then(</span><br><span class="line">  script =&gt; alert(<span class="string">`<span class="subst">$&#123;script.src&#125;</span> is loaded!`</span>),</span><br><span class="line">  error =&gt; alert(<span class="string">`Error: <span class="subst">$&#123;error.message&#125;</span>`</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">script</span> =&gt;</span> alert(<span class="string">'One more handler to do something else!'</span>));</span><br></pre></td></tr></table></figure>
<p>通过与这种基于回调函数语法的对比，我们可以立即找出一些优点：</p>
<p>callback：</p>
<ul>
<li>我们必须提前准备好<code>callback</code>函数，也就是说我们必须在<code>loadScript</code>调用之前就要处理结果。</li>
<li>只能有一个callback。</li>
</ul>
<p>Promise：</p>
<ul>
<li>Promise可以让我们用一种非常自然的顺序来编写代码。首先我们运行<code>loadScript</code>， 然后再继续写处理结果的逻辑。</li>
<li>我们可以事后多次调用<code>.then</code></li>
</ul>
<p>所以promise给我们带来了更好的代码流和灵活性。但是不只是这些，我们下章再继续。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="雯子" />
            
              <p class="site-author-name" itemprop="name">雯子</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">27</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/athena0304" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://segmentfault.com/u/oxw" target="_blank" title="segmentfault"><i class="fa fa-fw fa-globe"></i>segmentfault</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://juejin.im/user/582419f30ce4630058b08dc0" target="_blank" title="掘金"><i class="fa fa-fw fa-globe"></i>掘金</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright"> &copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">雯子</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Pisces</a> v6.4.2</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.2"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.2"></script>



  



  










  





  

  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
